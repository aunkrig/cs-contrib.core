
# This file was generated by the CS doclet; see http://cs-contrib.unkrig.de.

# Rule groups:
Coding.group     = Coding Problems
Naming.group     = Naming Conventions
Whitespace.group = Whitespace

# Custom checks, in alphabetical order.

# --------------- de.unkrig: Alignment ---------------

Alignment.name = de.unkrig: Alignment
Alignment.desc =\
	Verifies that Java elements are vertically aligned in immediately consecutive lines (and only there!):\n\
	<pre>\n\
	public class Main {\n\
	\n\
	\    int    <font color="red">x</font> = 7;\n\
	\    double <font color="red">xxx</font> = 7.0;              // Aligned field names\n\
	\n\
	\    int y      <font color="red">=</font> 7;\n\
	\    double yyy <font color="red">=</font> 7.0;              // Aligned field initializers\n\
	\n\
	\    public static void meth1(\n\
	\        String[] <font color="red">p1</font>,\n\
	\        int      <font color="red">p2</font>                // Aligned parameter names\n\
	\    ) {\n\
	\n\
	\        int    <font color="red">x</font> = 7;\n\
	\        double <font color="red">xxx</font> = 7.0;          // Aligned local variable names\n\
	\n\
	\        int y      <font color="red">=</font> 7;\n\
	\        double yyy <font color="red">=</font> 7.0;          // Aligned local variable initializers\n\
	\n\
	\        y   <font color="red">=</font> 8;\n\
	\        yyy <font color="red">=</font> 8.0;                 // Aligned assignments\n\
	\n\
	\        switch (x) {\n\
	\        case 1:  <font color="red">break;</font>\n\
	\        default: <font color="red">x++;</font> return;      // Aligned case groups statements\n\
	\        }\n\
	\    }\n\
	\n\
	\    public static void <font color="red">meth2</font>() {}\n\
	\    public void        <font color="red">meth33</font>() {} // Aligned method names\n\
	\n\
	\    public static void meth4()  <font color="red">{}</font>\n\
	\    public void meth5()         <font color="red">{}</font> // Aligned method bodies\n\
	}</pre>
Alignment.applyToFieldName               = Check alignment of first name in field declarations.
Alignment.applyToFieldInitializer        = Check alignment of first '=' in field declarations.
Alignment.applyToParameterName           = Check alignment of method (and constructor) parameter names.
Alignment.applyToLocalVariableName       = Check alignment of first name in local variable declarations.
Alignment.applyToLocalVariableInitializer = Check alignment of first '=' in local variable declarations.
Alignment.applyToAssignments             = Check alignment of '=' in assignments.
Alignment.applyToCaseGroupStatements     = Check alignment of first statement in case groups.
Alignment.applyToMethodName              = Check alignment of method (and constructor) names in declarations.
Alignment.applyToMethodBody              = Check alignment of '{' in method (and constructor) declarations.

# --------------- de.unkrig: C++-style comment alignment ---------------

CppCommentAlignment.name = de.unkrig: C++-style comment alignment
CppCommentAlignment.desc =\
	Verifies that C++-style comments ('<code>// ...</code>') are correctly aligned.\n\
	<p>\n\
	C++-style comments must appear on the same column iff\n\
	<ul>\n\
	\  <li>They appear in immediately consecutive lines, and\n\
	\  <li>All of these lines are of the same 'kind' (see below)\n\
	</ul>\n\
	Each line of code relates to one of the following 'kinds':\n\
	<ul>\n\
	\  <li>A line which contains only a C++-style comment\n\
	\  <li>A line which contains only a switch label ('<code>case x:</code>' or '<code>default:</code>') and a C++-style comment\n\
	\  <li>Any other line\n\
	</ul>

# --------------- de.unkrig: Inner assignment ---------------

InnerAssignment.name = de.unkrig: Inner assignment
InnerAssignment.desc =\
	Assignments in expressions must be parenthesized, like "a = (b = c)" or "while ((a = b))".\n\
	<p>\n\
	\  An enhanced version of 'InnerAssignment': It comes with a quickfix for ECLIPSE-CS.\n\
	</p>\n\
	\n\
	<h4>Quickfixes:</h4>\n\
	<dl>\n\
	\  <dt>Zuweisung klammern\n\
	\  <dd>Zuweisung klammern um anzuzeigen dass sie gewollt ist\n\
	</dl>

# --------------- de.unkrig: Name spelling ---------------

NameSpelling.name = de.unkrig: Name spelling
NameSpelling.desc =\
	Verifies that the names of Java elements match, respectively no not match given patterns.\n\
	<p>\n\
	This check makes name checking more powerful, compared with CheckStyle's standard "Naming Conventions" checks:\n\
	</p>\n\
	<ul>\n\
	\  <li>Arbitrary sets of required/missing modifiers can be specified</li>\n\
	\  <li>\n\
	\    Name patterns can not only be enforced but also be forbidden (useful, e.g., to forbid certains styles of\n\
	\    hungarian notation)\n\
	\  </li>\n\
	\  <li>\n\
	\    Adds the possibility to check the names of annotations, annotation fields and <code>enum</code>s (which are missing\n\
	\    from the standard checks)\n\
	\  </li>\n\
	</ul>\n\
	<p>\n\
	\  This check supersedes all of the CheckStyle standard "Naming Conventions" checks:\n\
	</p>\n\
	<ul>\n\
	\  <li>Abstract Class Name</li>\n\
	\  <li>Class Type Parameter Name</li>\n\
	\  <li>Constant Names</li>\n\
	\  <li>Enum Values Name</li>\n\
	\  <li>Interface Type Parameter Name</li>\n\
	\  <li>Local Final Variable Names</li>\n\
	\  <li>Local Variable Names</li>\n\
	\  <li>Member Names</li>\n\
	\  <li>Method Names</li>\n\
	\  <li>Method Type Parameter Name</li>\n\
	\  <li>Package Names</li>\n\
	\  <li>Parameter Names</li>\n\
	\  <li>Static Variable Names</li>\n\
	\  <li>Type Names</li>\n\
	</ul>
NameSpelling.elements                    = Elements to apply this check to.
NameSpelling.requiredModifiers           = Apply only to declarations which have these modifiers.
NameSpelling.missingModifiers            = Apply only to declarations which do not have these modifiers.
NameSpelling.option                      = Whether to require or forbid that names match.
NameSpelling.format                      = The pattern to match the name against.

# --------------- de.unkrig: Parenthesis padding ---------------

ParenPad.name = de.unkrig: Parenthesis padding
ParenPad.desc =\
	Enhanced version of "ParenPad": NOSPACE now allows "<code>( // ...</code>".\n\
	<p>\n\
	\  <span style="color: red"><b>This check is superseded by <code>de.unkrig.Whitespace</code>.</b></span>\n\
	</p>
ParenPad.option                          = Whether space is required or forbidden.

# --------------- de.unkrig: Whitespace ---------------

Whitespace.name = de.unkrig: Whitespace
Whitespace.desc =\
	Verifies that tokens are, respectively are not preceded with (and/or followed by) whitespace.\n\
	<p>\n\
	\  This check supersedes all of CheckStyle's whitespace-related checks:\n\
	</p>\n\
	<ul>\n\
	\  <li>Generic Whitespace</li>\n\
	\  <li>Empty For Initializer Pad</li>\n\
	\  <li>Empty For Iterator Pad</li>\n\
	\  <li>No Whitespace After</li>\n\
	\  <li>No Whitespace Before</li>\n\
	\  <li>Method Parameter Pad</li>\n\
	\  <li>Paren Pad</li>\n\
	\  <li>Typecast Paren Pad</li>\n\
	\  <li>Whitespace After</li>\n\
	\  <li>Whitespace Around</li>\n\
	</ul>\n\
	<p>\n\
	\  , as well as\n\
	</p>\n\
	<ul>\n\
	\  <li>de.unkrig.ParenPad</li>\n\
	\  <li>de.unkrig.WhitespaceAround</li>\n\
	</ul>
Whitespace.whitespaceBefore              = The Java elements which must be preceded with whitespace (or a line break).
Whitespace.noWhitespaceBefore            = The Java elements which must not be preceded with whitespace (or are preceded with a line break).
Whitespace.whitespaceAfter               = The Java elements which must be followed by whitespace (or a line break).
Whitespace.noWhitespaceAfter             = The Java elements which must not be followed by whitespace (or are followed by a line break).

# --------------- de.unkrig: Whitespace around ---------------

WhitespaceAround.name = de.unkrig: Whitespace around
WhitespaceAround.desc =\
	Verifies that a token is surrounded by whitespace.\n\
	<p>\n\
	\  <span style="color: red"><b>This check is superseded by <code>de.unkrig.Whitespace</code>.</b></span>\n\
	</p>\n\
	<p>\n\
	\  Empty constructor bodies, method bodies, catch blocks and type bodies of the form\n\
	</p>\n\
	<pre>\n\
	public MyClass() {}           // empty constructor body\n\
	\n\
	public void func() {}         // empty method body\n\
	\n\
	public void func() {\n\
	\    new Object() {\n\
	\        // ...\n\
	\    }.hashCode();             // No space between '}' and '.' -- always allowed\n\
	\    try {\n\
	\        // ...\n\
	\    } catch {}                // empty catch block\n\
	}\n\
	\n\
	interface MyInterface {}      // emtpy type body\n\
	</pre>\n\
	<p>\n\
	\  may optionally be exempted from the policy using the allowEmptyMethods, allowEmptyConstructors, allowEmptyCatches\n\
	\  and allowEmptyTypes properties.\n\
	</p>
WhitespaceAround.tokens                  = Tokens to check.
WhitespaceAround.allowEmptyConstructors  = Allow empty constructor bodies.
WhitespaceAround.allowEmptyMethods       = Allow empty method bodies.
WhitespaceAround.allowEmptyCatches       = Allow empty catch blocks.
WhitespaceAround.allowEmptyTypes         = Allow empty class and interface bodies.
WhitespaceAround.ignoreEnhancedForColon  = Ignore the colon (":") token in enhanced FOR statements ("for (x : y) ...").

# --------------- de.unkrig: Wrap and indent ---------------

WrapAndIndent.name = de.unkrig: Wrap and indent
WrapAndIndent.desc =\
	Verifies that statements are uniformly wrapped and indented.\n\
	<p style="color: red">\n\
	\  <b>This check supersedes the following checks:</b>\n\
	</p>\n\
	<ul style="color: red">\n\
	\  <li>Left curly brace placement</li>\n\
	\  <li>Right curly brace placement</li>\n\
	\  <li>Operator wrap</li>\n\
	</ul>\n\
	\n\
	<h4>Quickfixes:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapAndIndent.basicOffset                = How many spaces to use for each new indentation level.
WrapAndIndent.allowOneLineElement        = Whether to allow certain elements completely in one line.
WrapAndIndent.allowElementWrapping       = Whether to allow wrapping-and-indenting of subelements; where subelements may or may not appear on one line.
WrapAndIndent.allowStrictElementWrapping = Whether to allow wrapping-and-indenting of subelements, where each subelement must strictly appear on a new line.
WrapAndIndent.allowWrapping              = Whether to allow wrapping at certain places.
WrapAndIndent.requireWrapping            = Whether to <i>require</i> wrapping at certain places.

# --------------- de.unkrig: Zero-parameter superconstructor invocation ---------------

ZeroParameterSuperconstructorInvocation.name = de.unkrig: Zero-parameter superconstructor invocation
ZeroParameterSuperconstructorInvocation.desc =\
	Verifies that no constructor calls the zero-parameter superconstructor.\n\
	<pre>\n\
	class Foo extends Bar {\n\
	\    Foo(int a, int b) {\n\
	\        <font color="red">super();</font>\n\
	\    }\n\
	}</pre>\n\
	\n\
	<h4>Quickfixes:</h4>\n\
	<dl>\n\
	\  <dt>Entfernen\n\
	\  <dd>Redundanten Aufruf des parameterlosen Superkonstruktors entfernen\n\
	</dl>
