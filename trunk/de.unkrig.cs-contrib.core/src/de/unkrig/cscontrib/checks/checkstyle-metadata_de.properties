
# Rule groups:
Coding.group     = Kodierungsprobleme
Naming.group     = Namenskonventionen
Whitespace.group = Leerraum

# Custom checks, in alphabetical order.

# --------------- de.unkrig: Alignment ---------------

Alignment.name = de.unkrig: Ausrichtung
Alignment.desc =\
	Überprüft, dass Java-Elemente in unmittelbar aufeinanderfolgenden Zeilen (und nur dort!) vertikal ausgerichtet sind:\n\
	<pre>\n\
	public class Main {\n\
	\n\
	\    int    <font color="red">x</font> = 7;\n\
	\    double <font color="red">xxx</font> = 7.0;              // Ausgerichtete Feldnamen\n\
	\n\
	\    int y      <font color="red">=</font> 7;\n\
	\    double yyy <font color="red">=</font> 7.0;              // Ausgerichtete Feld-Initialisierer\n\
	\n\
	\    public static void meth1(\n\
	\        String[] <font color="red">p1</font>,\n\
	\        int      <font color="red">p2</font>                // Ausgerichtete Parameternamen\n\
	\    ) {\n\
	\n\
	\        int    <font color="red">x</font> = 7;\n\
	\        double <font color="red">xxx</font> = 7.0;          // Ausgerichtete lokale Variablennamen\n\
	\n\
	\        int y      <font color="red">=</font> 7;\n\
	\        double yyy <font color="red">=</font> 7.0;          // Ausgerichtete lokale Variablen-Initialisierer\n\
	\n\
	\        y   <font color="red">=</font> 8;\n\
	\        yyy <font color="red">=</font> 8.0;                 // Ausgerichtete Zuweisungen\n\
	\n\
	\        switch (x) {\n\
	\        case 1:  <font color="red">break;</font>\n\
	\        default: <font color="red">x++;</font> return;      // Ausgerichtete Case-Gruppen-Statements\n\
	\        }\n\
	\    }\n\
	\n\
	\    public static void <font color="red">meth2</font>() {}\n\
	\    public void        <font color="red">meth33</font>() {} // Ausgerichtete Methodennamen\n\
	\n\
	\    public static void meth4()  <font color="red">{}</font>\n\
	\    public void meth5()         <font color="red">{}</font> // Ausgerichtete Methodenkörper\n\
	}</pre>
Alignment.applyToFieldName               = Überprüfe die Ausrichtung der ersten Namen in Felddeklarationen.
Alignment.applyToFieldInitializer        = Überprüfe die Ausrichtung der ersten '=' in Felddeklarationen.
Alignment.applyToParameterName           = Überprüfe die Ausrichtung der Methoden-(und Konstruktor-)Parameternamen.
Alignment.applyToLocalVariableName       = Überprüfe die Ausrichtung des ersten namen in lokalen Variablendeklarationen.
Alignment.applyToLocalVariableInitializer = Überprüfe die Ausrichtung der ersten '=' in lokalen Variablendeklarationen.
Alignment.applyToAssignments             = Überprüfe die Ausrichtung des '=' in Zuweisungen.
Alignment.applyToCaseGroupStatements     = Überprüfe die Ausrichtung der ersten Statements in Case-Gruppen.
Alignment.applyToMethodName              = Überprüfe die Ausrichtung der Methoden-(und Konstruktor-)Namen in Deklarationen.
Alignment.applyToMethodBody              = Überprüfe die Ausrichtung des '{' in Methoden-(und Konstruktor-)Deklarationen.

# --------------- de.unkrig: C++-style comment alignment ---------------

CppCommentAlignment.name = de.unkrig: Ausrichtung von C++-Kommentaren
CppCommentAlignment.desc =\
	Überprüft, dass C++-Kommentare ('<code>// ...</code>') korrekt ausgerichtet sind.\n\
	<p>\n\
	C++-Kommentare müssen in derselben Spalte beginnen wenn (und nur wenn)\n\
	<ul>\n\
	\  <li>Sie in unmittelbar aufeinanderfolgenden Zeilen stehen, und\n\
	\  <li>Alle diese Zeilen von derselben 'Art' sind (s.u.)\n\
	</ul>\n\
	Jede Codezeile ist von einer der folgenden 'Arten':\n\
	<ul>\n\
	\  <li>Eine Zeile, die ausschließlichen einen C++-Kommentar enthält\n\
	\  <li>Eine Zeile, die ausschließlich ein SWITCH-Label ('<code>case x:</code>' or '<code>default:</code>') und einen C++-Kommentar enthält\n\
	\  <li>Jede andere Zeile\n\
	</ul>

# --------------- de.unkrig: Inner assignment ---------------

InnerAssignment.name = de.unkrig: Innere Zuweisung
InnerAssignment.desc =\
	Zuweisungen innerhalb von Ausdrücken müssen in Klammern gesetzt werden, etwa "a = (b = c)" oder "while ((a = b))".\n\
	<p>\n\
	\  Dies ist eine Verbesserung von 'InnerAssignment': Es gibt einen Quickfix für ECLIPSE-CS.\n\
	</p>\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zuweisung klammern\n\
	\  <dd>Zuweisung klammern um anzuzeigen dass sie gewollt ist\n\
	</dl>

# --------------- de.unkrig: Name spelling ---------------

NameSpelling.name = de.unkrig: Namensschreibweise
NameSpelling.desc =\
	Überprüft, dass die Namen von Java-Elementen einen bestimmten Muster entsprechen, bzw. <i>nicht</i> entsprechen.\n\
	<p>\n\
	Durch diesen Check wird die Namensschreibweisen-Prüfung leistungsfähiger im Vergleich zu den Standard-"Naming\n\
	Conventions"-Checks von CheckStyle:\n\
	</p>\n\
	<ul>\n\
	\  <li>Beliebige Kombinationen von erforderlichen/fehlenden Modifiern können angegeben werden</li>\n\
	\  <li>\n\
	\    Namensmuster können nicht nur <i>vorgeschrieben</i>, sondern auch <i>verboten</i> werden (nützlich, um z.B.\n\
	\    bestimmte Stile der "Ungarischen Notation" zu verbieten)\n\
	\  </li>\n\
	\  <li>\n\
	\    Ermöglicht es zusätzlich, die Namen von Annotationen, Annotationsfeldern und <code>enum</code>s zu\n\
	\    überprüfen (was mit den Standard-Checks nicht möglich ist)\n\
	\  </li>\n\
	</ul>\n\
	<p>\n\
	\  Dieser Check löst alle folgenden Standard-"Naming Conventions"-Checks von CheckStyle ab:\n\
	</p>\n\
	<ul>\n\
	\  <li>Abstract Class Name</li>\n\
	\  <li>Class Type Parameter Name</li>\n\
	\  <li>Constant Names</li>\n\
	\  <li>Enum Values Name</li>\n\
	\  <li>Interface Type Parameter Name</li>\n\
	\  <li>Local Final Variable Names</li>\n\
	\  <li>Local Variable Names</li>\n\
	\  <li>Member Names</li>\n\
	\  <li>Method Names</li>\n\
	\  <li>Method Type Parameter Name</li>\n\
	\  <li>Package Names</li>\n\
	\  <li>Parameter Names</li>\n\
	\  <li>Static Variable Names</li>\n\
	\  <li>Type Names</li>\n\
	</ul>
NameSpelling.elements                    = Elemente, auf die der Check angewendet wird.
NameSpelling.requiredModifiers           = Nur auf Elemente mit diesen Modifiern anwenden.
NameSpelling.missingModifiers            = Nur auf Elemente OHNE diese Modifier anwenden.
NameSpelling.option                      = Ob Namen dem Muster entsprechen MÜSSEN oder NICHT ENTSPRECHEN DÜRFEN.
NameSpelling.format                      = Das Muster, das auf die Namen angewendet wird.

# --------------- de.unkrig: Parenthesis padding ---------------

ParenPad.name = de.unkrig: Leerraum um runde Klammern
ParenPad.desc =\
	Verbesserte Version von "ParenPad": NOSPACE lässt nun "<code>( // ...</code>" zu.\n\
	<p>\n\
	\  <span style="color: red"><b>Dieser Check wurde durch "<code>de.unkrig: Whitespace</code>" abgelöst.</b></span>\n\
	</p>
ParenPad.option                          = Ob Leerraum um runde Klammer VORGESCHRIEBEN ist oder VERBOTEN.

# --------------- de.unkrig: Whitespace ---------------

Whitespace.name = de.unkrig: Leerraum
Whitespace.desc =\
	Überprüft, dass vor und/oder nach bestimmten Token Leerraum steht oder <i>nicht</i> steht.\n\
	<p>\n\
	\  Dieser Check löst sowohl alle Standard-CheckStyle-Checks, die Leerraum überprüft, ab\n\
	</p>\n\
	<ul>\n\
	\  <li>Generic Whitespace</li>\n\
	\  <li>Empty For Initializer Pad</li>\n\
	\  <li>Empty For Iterator Pad</li>\n\
	\  <li>No Whitespace After</li>\n\
	\  <li>No Whitespace Before</li>\n\
	\  <li>Method Parameter Pad</li>\n\
	\  <li>Paren Pad</li>\n\
	\  <li>Typecast Paren Pad</li>\n\
	\  <li>Whitespace After</li>\n\
	\  <li>Whitespace Around</li>\n\
	</ul>\n\
	<p>\n\
	\  als auch\n\
	</p>\n\
	<ul>\n\
	\  <li>de.unkrig: Leerraum um runde Klammern</li>\n\
	\  <li>de.unkrig: Leerraum um Token</li>\n\
	</ul>
Whitespace.whitespaceBefore              = Die Java-Elemente, vor denen Leeraum stehen muss (oder ein Zeilenumbruch).
Whitespace.noWhitespaceBefore            = Die Java-Elemente, vor denen kein Leerraum stehen darf (oder die auf einen Zeilenumbruch folgen).
Whitespace.whitespaceAfter               = Die Java-Elemente, nach denen Leeraum stehen muss (oder ein Zeilenumbruch).
Whitespace.noWhitespaceAfter             = Die Java-Elemente, nach denen kein Leerraum stehen darf (oder auf die einen Zeilenumbruch folgen).

# --------------- de.unkrig: Whitespace around ---------------

WhitespaceAround.name = de.unkrig: Leerraum um Token
WhitespaceAround.desc =\
	Überprüft, dass ein Token von Leerraum umgeben ist.\n\
	<p>\n\
	\  <span style="color: red"><b>Dieser Check wurde abgelöst durch "<code>de.unkrig: Leerraum</code>".</b></span>\n\
	</p>\n\
	<p>\n\
	\  Leere Konstruktor-Körper, Method-Körper, CATCH-Blöcke und Typ-Körper in der Form\n\
	</p>\n\
	<pre>\n\
	public MyClass() {}           // Leerer Konstruktor-Körper\n\
	\n\
	public void func() {}         // Leerer Methoden-Körper\n\
	\n\
	public void func() {\n\
	\    new Object() {\n\
	\        // ...\n\
	\    }.hashCode();             // Kein Leerraum zwischen '}' und '.' -- immer erlaubt\n\
	\    try {\n\
	\        // ...\n\
	\    } catch {}                // Leerer CATCH-Block\n\
	}\n\
	\n\
	interface MyInterface {}      // Leerer Typ-Körper\n\
	</pre>\n\
	<p>\n\
	\  können optional von dieser Regel ausgenommen werden mittels der Properties "allowEmptyMethods",\n\
	\  "allowEmptyConstructors", "allowEmptyCatches" und "allowEmptyTypes".\n\
	</p>
WhitespaceAround.tokens                  = Zu überprüfende Token
WhitespaceAround.allowEmptyConstructors  = Lasse leere Konstruktor-Körper zu.
WhitespaceAround.allowEmptyMethods       = Lasse leere methoden-Körper zu.
WhitespaceAround.allowEmptyCatches       = Lasse leere CATCH-Blöcke zu.
WhitespaceAround.allowEmptyTypes         = Lasse leere Typ-Körper zu.
WhitespaceAround.ignoreEnhancedForColon  = Ignore den Doppelpunkt (":") in "Enhanced FOR"-Statements ("for (x : y) ...").

# --------------- de.unkrig: Wrap and indent ---------------

WrapAndIndent.name = de.unkrig: Umbruch und Einrückung
WrapAndIndent.desc =\
	Überprüft, dass Statements einheitlich umbrochen und eingerückt sind.\n\
	<p style="color: red">\n\
	\  <b>Dieser Check löst folgende Checks ab:</b>\n\
	</p>\n\
	<ul style="color: red">\n\
	\  <li>Left curly brace placement</li>\n\
	\  <li>Right curly brace placement</li>\n\
	\  <li>Operator wrap</li>\n\
	</ul>\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapAndIndent.basicOffset                = Anzahl Leerzeichen pro Einrückungsebene.
WrapAndIndent.allowOneLineClassDecl      = Ob einzeilige Klassendeklarationen erlaubt sind.
WrapAndIndent.allowOneLineInterfaceDecl  = Ob einzeilige Interfacedeklarationen erlaubt sind.
WrapAndIndent.allowOneLineEnumDecl       = Ob einzeilige ENUM-Deklarationen erlaubt sind.
WrapAndIndent.allowOneLineAnnoDecl       = Ob einzeilige Annotationsdeklarationen erlaubt sind.
WrapAndIndent.allowOneLineCtorDecl       = Ob einzeilige Konstruktordeklarationen erlaubt sind.
WrapAndIndent.allowOneLineMethDecl       = Ob einzeilige Methodendeklarationen erlaubt sind.
WrapAndIndent.allowOneLineSwitchBlockStmtGroup = Ob einzeilige SWITCH-Block-Statement-Gruppen erlaubt sind.
WrapAndIndent.wrapPackageDeclBeforePackage = Ob Package-Deklarationen (in "package-info.java") vor dem Schlüsselwort 'PACKAGE' umbrochen werden.
WrapAndIndent.wrapClassDeclBeforeClass   = Ob Klassendeklarationen vor dem Schlüsselwort 'CLASS' umbrochen werden.
WrapAndIndent.wrapInterfaceDeclBeforeInterface = Ob Interfacedeklarationen vor dem Schlüsselwort 'INTERFACE' umbrochen werden.
WrapAndIndent.wrapEnumDeclBeforeEnum     = Ob ENUM-Deklarationen vor dem Schlüsselwort 'ENUM' umbrochen werden.
WrapAndIndent.wrapAnnoDeclBeforeAt       = Ob Annotations-Deklarations vor dem '@' umbrochen werden.
WrapAndIndent.wrapFieldDeclBeforeName    = Ob Felddeklarationen vor dem Feldnamen umbrochen werden.
WrapAndIndent.wrapCtorDeclBeforeName     = Ob Konstruktordeklarationen zwischen den Modifiern und dem Klassennamen umbrochen werden.
WrapAndIndent.wrapMethDeclBeforeName     = Ob Methodendeklarationen zwischen dem Rückgabetyp und dem und dem Methodennamen umbrochen werden.
WrapAndIndent.wrapLocVarDeclBeforeName   = Ob lokale Variablendeklarationen zwischen dem Typ und dem Variablennamen umbrochen werden.
WrapAndIndent.wrapTypeDeclBeforeLCurly   = Ob Typdeklarationen vor der öffnenden geschweiften Klammer umbrochen werden.
WrapAndIndent.wrapCtorDeclBeforeLCurly   = Ob Konstruktordeklarationen vor der öffnenden geschweiften Klammer umbrochen werden.
WrapAndIndent.wrapMethodDeclBeforeLCurly = Ob Methodendeklarationen vor der öffnenden geschweiften Klammer umbrochen werden.
WrapAndIndent.wrapAnonClassDeclBeforeLCurly = Ob anonyme Klassendeklarationen vor der öffnenden geschweiften Klammer umbrochen werden.
WrapAndIndent.wrapDoBeforeLCurly         = Ob DO-Statements vor der öffnenden geschweiften Klammer umbrochen werden.
WrapAndIndent.wrapTryBeforeCatch         = Ob TRY-Statements vor dem Schlüsselwort 'CATCH' umbrochen werden.
WrapAndIndent.wrapTryBeforeFinally       = Ob TRY-Statements vor dem Schlüsselwort 'FINALLY' umbrochen werden.
WrapAndIndent.wrapArrayInitBeforeLCurly  = Ob Array-Initialisierer vor der öffnenden geschweiften Klammer umbrochen werden.
WrapAndIndent.wrapBeforeBinaryOperator   = Ob Ausdrücke vor binären Operatoren umbrochen werden.
WrapAndIndent.wrapAfterBinaryOperator    = Ob Ausdrücke nach binären Operatoren umbrochen werden.

# --------------- de.unkrig: Zero-parameter superconstructor invocation ---------------

ZeroParameterSuperconstructorInvocation.name = de.unkrig: Aufruf des parameterlosen Superkonstruktors
ZeroParameterSuperconstructorInvocation.desc =\
	Überprüft, dass kein Konstruktor den parameterlosen Superkonstruktor aufruft:\n\
	<pre>\n\
	class Foo extends Bar {\n\
	\    Foo(int a, int b) {\n\
	\        <font color="red">super();</font>\n\
	\    }\n\
	
	}</pre>\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Entfernen\n\
	\  <dd>Redundanten Aufruf des parameterlosen Superkonstruktors entfernen\n\
	</dl>
