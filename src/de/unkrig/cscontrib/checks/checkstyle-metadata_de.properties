
# Rule groups:
Coding.group     = Kodierungsprobleme
Naming.group     = Namenskonventionen
Whitespace.group = Leerraum

# Custom checks, in alphabetical order.

# --------------- de.unkrig: Alignment ---------------

Alignment.name = de.unkrig: Ausrichtung
Alignment.desc =\
	Überprüft, dass Java-Elemente in unmittelbar aufeinanderfolgenden Zeilen (und nur dort!) vertikal ausgerichtet sind:\n\
	<pre>\n\
	public class Main {\n\
	\n\
	\    int    <font color="red">x</font> = 7;\n\
	\    double <font color="red">xxx</font> = 7.0;              // Ausgerichtete Feldnamen\n\
	\n\
	\    int y      <font color="red">=</font> 7;\n\
	\    double yyy <font color="red">=</font> 7.0;              // Ausgerichtete Feld-Initialisierer\n\
	\n\
	\    public static void meth1(\n\
	\        String[] <font color="red">p1</font>,\n\
	\        int      <font color="red">p2</font>                // Ausgerichtete Parameternamen\n\
	\    ) {\n\
	\n\
	\        int    <font color="red">x</font> = 7;\n\
	\        double <font color="red">xxx</font> = 7.0;          // Ausgerichtete lokale Variablennamen\n\
	\n\
	\        int y      <font color="red">=</font> 7;\n\
	\        double yyy <font color="red">=</font> 7.0;          // Ausgerichtete lokale Variablen-Initialisierer\n\
	\n\
	\        y   <font color="red">=</font> 8;\n\
	\        yyy <font color="red">=</font> 8.0;                 // Ausgerichtete Zuweisungen\n\
	\n\
	\        switch (x) {\n\
	\        case 1:  <font color="red">break;</font>\n\
	\        default: <font color="red">x++;</font> return;      // Ausgerichtete Case-Gruppen-Statements\n\
	\        }\n\
	\    }\n\
	\n\
	\    public static void <font color="red">meth2</font>() {}\n\
	\    public void        <font color="red">meth33</font>() {} // Ausgerichtete Methodennamen\n\
	\n\
	\    public static void meth4()  <font color="red">{}</font>\n\
	\    public void meth5()         <font color="red">{}</font> // Ausgerichtete Methodenkörper\n\
	}</pre>
Alignment.applyToFieldName               = Überprüfe die Ausrichtung der ersten Namen in Felddeklarationen.
Alignment.applyToFieldInitializer        = Überprüfe die Ausrichtung der ersten '=' in Felddeklarationen.
Alignment.applyToParameterName           = Überprüfe die Ausrichtung der Methoden-(und Konstruktor-)Parameternamen.
Alignment.applyToLocalVariableName       = Überprüfe die Ausrichtung des ersten namen in lokalen Variablendeklarationen.
Alignment.applyToLocalVariableInitializer = Überprüfe die Ausrichtung der ersten '=' in lokalen Variablendeklarationen.
Alignment.applyToAssignments             = Überprüfe die Ausrichtung des '=' in Zuweisungen.
Alignment.applyToCaseGroupStatements     = Überprüfe die Ausrichtung der ersten Statements in Case-Gruppen.
Alignment.applyToMethodName              = Überprüfe die Ausrichtung der Methoden-(und Konstruktor-)Namen in Deklarationen.
Alignment.applyToMethodBody              = Überprüfe die Ausrichtung des '{' in Methoden-(und Konstruktor-)Deklarationen.

# --------------- de.unkrig: C++-style comment alignment ---------------

CppCommentAlignment.name = de.unkrig: Ausrichtung von C++-Kommentaren
CppCommentAlignment.desc =\
	Überprüft, dass C++-Kommentare ('<code>// ...</code>') korrekt ausgerichtet sind.\n\
	<p>\n\
	C++-Kommentare müssen in derselben Spalte beginnen wenn (und nur wenn)\n\
	<ul>\n\
	\  <li>Sie in unmittelbar aufeinanderfolgenden Zeilen stehen, und\n\
	\  <li>Alle diese Zeilen von derselben 'Art' sind (s.u.)\n\
	</ul>\n\
	Jede Codezeile ist von einer der folgenden 'Arten':\n\
	<ul>\n\
	\  <li>Eine Zeile, die ausschließlichen einen C++-Kommentar enthält\n\
	\  <li>Eine Zeile, die ausschließlich ein SWITCH-Label ('<code>case x:</code>' or '<code>default:</code>') und einen C++-Kommentar enthält\n\
	\  <li>Jede andere Zeile\n\
	</ul>

# --------------- de.unkrig: Inner assignment ---------------

InnerAssignment.name = de.unkrig: Innere Zuweisung
InnerAssignment.desc =\
	Zuweisungen innerhalb von Ausdrücken müssen in Klammern gesetzt werden, etwa "a = (b = c)" oder "while ((a = b))".\n\
	<p>\n\
	\  Dies ist eine Verbesserung von 'InnerAssignment': Es gibt einen Quickfix für ECLIPSE-CS.\n\
	</p>\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zuweisung klammern\n\
	\  <dd>Zuweisung klammern um anzuzeigen dass sie gewollt ist\n\
	</dl>

# --------------- de.unkrig: Name spelling ---------------

NameSpelling.name = de.unkrig: Namensschreibweise
NameSpelling.desc =\
	Überprüft, dass die Namen von Java-Elementen einen bestimmten Muster entsprechen, bzw. <i>nicht</i> entsprechen.\n\
	<p>\n\
	Durch diesen Check wird die Namensschreibweisen-Prüfung leistungsfähiger im Vergleich zu den Standard-"Naming\n\
	Conventions"-Checks von CheckStyle:\n\
	</p>\n\
	<ul>\n\
	\  <li>Beliebige Kombinationen von erforderlichen/fehlenden Modifiern können angegeben werden</li>\n\
	\  <li>\n\
	\    Namensmuster können nicht nur <i>vorgeschrieben</i>, sondern auch <i>verboten</i> werden (nützlich, um z.B.\n\
	\    bestimmte Stile der "Ungarischen Notation" zu verbieten)\n\
	\  </li>\n\
	\  <li>\n\
	\    Ermöglicht es zusätzlich, die Namen von Annotationen, Annotationsfeldern und <code>enum</code>s zu\n\
	\    überprüfen (was mit den Standard-Checks nicht möglich ist)\n\
	\  </li>\n\
	</ul>\n\
	<p>\n\
	\  Dieser Check löst alle folgenden Standard-"Naming Conventions"-Checks von CheckStyle ab:\n\
	</p>\n\
	<ul>\n\
	\  <li>Abstract Class Name</li>\n\
	\  <li>Class Type Parameter Name</li>\n\
	\  <li>Constant Names</li>\n\
	\  <li>Enum Values Name</li>\n\
	\  <li>Interface Type Parameter Name</li>\n\
	\  <li>Local Final Variable Names</li>\n\
	\  <li>Local Variable Names</li>\n\
	\  <li>Member Names</li>\n\
	\  <li>Method Names</li>\n\
	\  <li>Method Type Parameter Name</li>\n\
	\  <li>Package Names</li>\n\
	\  <li>Parameter Names</li>\n\
	\  <li>Static Variable Names</li>\n\
	\  <li>Type Names</li>\n\
	</ul>
NameSpelling.elements                    = Elemente, auf die der Check angewendet wird.
NameSpelling.requiredModifiers           = Nur auf Elemente mit diesen Modifiern anwenden.
NameSpelling.missingModifiers            = Nur auf Elemente OHNE diese Modifier anwenden.
NameSpelling.option                      = Ob Namen dem Muster entsprechen MÜSSEN oder NICHT ENTSPRECHEN DÜRFEN.
NameSpelling.format                      = Das Muster, das auf die Namen angewendet wird.

# --------------- de.unkrig: Parenthesis padding ---------------

ParenPad.name = de.unkrig: Leerraum um runde Klammern
ParenPad.desc =\
	Verbesserte Version von "ParenPad": NOSPACE lässt nun "<code>( // ...</code>" zu.\n\
	<p>\n\
	\  <span style="color: red"><b>Dieser Check wurde durch "<code>de.unkrig: Whitespace</code>" abgelöst.</b></span>\n\
	</p>
ParenPad.option                          = Ob Leerraum um runde Klammer VORGESCHRIEBEN ist oder VERBOTEN.

# --------------- de.unkrig: Whitespace ---------------

Whitespace.name = de.unkrig: Leerraum
Whitespace.desc =\
	Überprüft, dass vor und/oder nach bestimmten Token Leerraum steht oder <i>nicht</i> steht.\n\
	<p>\n\
	\  Dieser Check löst sowohl alle Standard-CheckStyle-Checks, die Leerraum überprüft, ab\n\
	</p>\n\
	<ul>\n\
	\  <li>Generic Whitespace</li>\n\
	\  <li>Empty For Initializer Pad</li>\n\
	\  <li>Empty For Iterator Pad</li>\n\
	\  <li>No Whitespace After</li>\n\
	\  <li>No Whitespace Before</li>\n\
	\  <li>Method Parameter Pad</li>\n\
	\  <li>Paren Pad</li>\n\
	\  <li>Typecast Paren Pad</li>\n\
	\  <li>Whitespace After</li>\n\
	\  <li>Whitespace Around</li>\n\
	</ul>\n\
	<p>\n\
	\  als auch\n\
	</p>\n\
	<ul>\n\
	\  <li>de.unkrig: Leerraum um runde Klammern</li>\n\
	\  <li>de.unkrig: Leerraum um Token</li>\n\
	</ul>
Whitespace.whitespaceBefore              = Die Java-Elemente, vor denen Leeraum stehen muss (oder ein Zeilenumbruch).
Whitespace.noWhitespaceBefore            = Die Java-Elemente, vor denen kein Leerraum stehen darf (oder die auf einen Zeilenumbruch folgen).
Whitespace.whitespaceAfter               = Die Java-Elemente, nach denen Leeraum stehen muss (oder ein Zeilenumbruch).
Whitespace.noWhitespaceAfter             = Die Java-Elemente, nach denen kein Leerraum stehen darf (oder auf die einen Zeilenumbruch folgen).

# --------------- de.unkrig: Whitespace around ---------------

WhitespaceAround.name = de.unkrig: Leerraum um Token
WhitespaceAround.desc =\
	Überprüft, dass ein Token von Leerraum umgeben ist.\n\
	<p>\n\
	\  <span style="color: red"><b>Dieser Check wurde abgelöst durch "<code>de.unkrig: Leerraum</code>".</b></span>\n\
	</p>\n\
	<p>\n\
	\  Leere Konstruktor-Körper, Method-Körper, CATCH-Blöcke und Typ-Körper in der Form\n\
	</p>\n\
	<pre>\n\
	public MyClass() {}           // Leerer Konstruktor-Körper\n\
	\n\
	public void func() {}         // Leerer Methoden-Körper\n\
	\n\
	public void func() {\n\
	\    new Object() {\n\
	\        // ...\n\
	\    }.hashCode();             // Kein Leerraum zwischen '}' und '.' -- immer erlaubt\n\
	\    try {\n\
	\        // ...\n\
	\    } catch {}                // Leerer CATCH-Block\n\
	}\n\
	\n\
	interface MyInterface {}      // Leerer Typ-Körper\n\
	</pre>\n\
	<p>\n\
	\  können optional von dieser Regel ausgenommen werden mittels der Properties "allowEmptyMethods",\n\
	\  "allowEmptyConstructors", "allowEmptyCatches" und "allowEmptyTypes".\n\
	</p>
WhitespaceAround.tokens                  = Zu überprüfende Token
WhitespaceAround.allowEmptyConstructors  = Lasse leere Konstruktor-Körper zu.
WhitespaceAround.allowEmptyMethods       = Lasse leere methoden-Körper zu.
WhitespaceAround.allowEmptyCatches       = Lasse leere CATCH-Blöcke zu.
WhitespaceAround.allowEmptyTypes         = Lasse leere Typ-Körper zu.
WhitespaceAround.ignoreEnhancedForColon  = Ignore den Doppelpunkt (":") in "Enhanced FOR"-Statements ("for (x : y) ...").

# --------------- de.unkrig: Wrap annotation ---------------

WrapAnnotationCheck.name = de.unkrig: Umbruch Annotationen
WrapAnnotationCheck.desc =\
	Überprüft, dass Annotations-Typ-Deklarationen einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapAnnotationCheck.allowOneLineDecl                 = Ob die komplette Deklaration in einer einzigen Zeile stehen darf.
WrapAnnotationCheck.wrapDeclBeforeAt                 = Ob vor dem "@" umbrochen wird.
WrapAnnotationCheck.wrapDeclBeforeLCurly             = Ob vor der "{" umbrochen wird.
WrapAnnotationCheck.allowMultiplePerLine             = Ob mehrere Annotation pro Zeile erlaubt sind.
WrapAnnotationCheck.allowMultipleInitializersPerLine = Ob mehrere Annotation-Initialisierer pro Zeile erlaubt sind.

# --------------- de.unkrig: Wrap array initializer ---------------

WrapArrayInitCheck.name = de.unkrig: Umbruch Array-Initialisierer
WrapArrayInitCheck.desc =\
	Überprüft, dass Array-Initialisierer einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapArrayInitCheck.wrapBeforeLCurly           = Ob vor der "{" umbrochen wird.
WrapArrayInitCheck.allowMultipleValuesPerLine = Ob mehrere Initialisierungswerte pro Zeile erlaubt sind.

# --------------- de.unkrig: Wrap binary operator ---------------

WrapBinaryOperatorCheck.name = de.unkrig: Umbruch Binäre Operatoren
WrapBinaryOperatorCheck.desc =\
	Überprüft, dass binäre Operationen einheitlich vor und/oder nach dem Operator umbrochen sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapBinaryOperatorCheck.wrapBeforeOperator = Ob binäre Ausdrücke VOR dem Operator umbrochen werden.
WrapBinaryOperatorCheck.wrapAfterOperator  = Ob binäre Ausdrücke NACH dem Operator umbrochen werden.

# --------------- de.unkrig: Wrap class ---------------

WrapClassCheck.name = de.unkrig: Umbruch Klassen
WrapClassCheck.desc =\
	Überprüft, dass Klassen-Declarationen einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapClassCheck.allowOneLineDecl          = Ob die komplette Deklaration in einer einzigen Zeile stehen darf.
WrapClassCheck.wrapDeclBeforeClass       = Ob vor dem Schlüsselwort "class" umbrochen wird.
WrapClassCheck.wrapDeclBeforeLCurly      = Ob vor der "{" umbrochen wird.

# --------------- de.unkrig: Wrap constructor ---------------

WrapCtorCheck.name = de.unkrig: Umbruch Konstructoren
WrapCtorCheck.desc =\
	Überprüft, dass Konstructor-Deklarationen, -Parameter and -Argumente einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapCtorCheck.allowOneLineDecl           = Ob die komplette Deklaration in einer einzigen Zeile stehen darf.
WrapCtorCheck.wrapDeclBeforeName         = Ob vor dem Namen umbrochen wird.
WrapCtorCheck.wrapDeclBeforeLCurly       = Ob vor der "{" umbrochen wird.
WrapCtorCheck.allowMultipleArgsPerLine   = Ob mehrere Argumente pro Zeile erlaubt sind.
WrapCtorCheck.allowMultipleParametersPerLine = Ob mehrere Parameter pro Zeile erlaubt sind.

# --------------- de.unkrig: Wrap DO statement ---------------

WrapDoCheck.name = de.unkrig: Umbruch DO-Statement
WrapDoCheck.desc =\
	Überprüft, dass DO-Statements einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapDoCheck.wrapBeforeLCurly             = Ob vor der "{" umbrochen wird.

# --------------- de.unkrig: Wrap enum ---------------

WrapEnumCheck.name = de.unkrig: Umbruch Enum
WrapEnumCheck.desc =\
	Überprüft, dass Enum-Deklarationen und -Konstanten einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapEnumCheck.allowOneLineDecl           = Ob die komplette Deklaration in einer einzigen Zeile stehen darf.
WrapEnumCheck.wrapDeclBeforeEnum         = Ob vor dem Schlüsselwort "enum" umbrochen wird.
WrapEnumCheck.wrapDeclBeforeLCurly       = Ob vor der "{" umbrochen wird.
WrapEnumCheck.allowMultipleConstantsPerLine = Ob mehrere Enum-Konstanten pro Zeile erlaubt sind.

# --------------- de.unkrig: Wrap field ---------------

WrapFieldCheck.name = de.unkrig: Umbruch Felder
WrapFieldCheck.desc =\
	Überprüft, dass Feld-Dellarationen einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapFieldCheck.wrapDeclBeforeName = Ob vor dem Namen umbrochen wird.

# --------------- de.unkrig: Wrap interface ---------------

WrapInterfaceCheck.name = de.unkrig: Umbruch Interfaces
WrapInterfaceCheck.desc =\
	Überprüft, dass Interface-Deklarationen einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapInterfaceCheck.allowOneLineDecl        = Ob die komplette Deklaration in einer einzigen Zeile stehen darf.
WrapInterfaceCheck.wrapDeclBeforeInterface = Ob vor dem Schlüsselwort "interface" umbrochen wird.
WrapInterfaceCheck.wrapDeclBeforeLCurly    = Ob vor der "{" umbrochen wird.

# --------------- de.unkrig: Wrap local class ---------------

WrapLocalClassCheck.name = de.unkrig: Umbruch lokale Klassen
WrapLocalClassCheck.desc =\
	Überprüft, dass Deklarationen von lokalen Klassen einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapLocalClassCheck.wrapDeclBeforeLCurly = Ob vor der "{" umbrochen wird.

# --------------- de.unkrig: Wrap local variable ---------------

WrapLocalVariableCheck.name = de.unkrig: Umbruch lokale Variablen
WrapLocalVariableCheck.desc =\
	Überprüft, dass Deklarationen von lokalen Variablen einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapLocalVariableCheck.wrapDeclBeforeName = Ob vor dem Namen umbrochen wird.

# --------------- de.unkrig: Wrap method ---------------

WrapMethodCheck.name = de.unkrig: Umbruch Methoden
WrapMethodCheck.desc =\
	Überprüft, dass Methoden-Deklarationen, -Parameter und Aufruf-Argumente einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapMethodCheck.allowOneLineDecl         = Ob die komplette Deklaration in einer einzigen Zeile stehen darf.
WrapMethodCheck.wrapDeclBeforeName       = Ob vor dem Namen umbrochen wird.
WrapMethodCheck.wrapMethodDeclBeforeLCurly = Ob vor der "{" umbrochen wird.
WrapMethodCheck.allowMultipleArgsPerLine = Ob mehrere Argumente pro Zeile erlaubt sind.
WrapMethodCheck.allowMultipleParametersPerLine = Ob mehrere Parameter pro Zeile erlaubt sind.

# --------------- de.unkrig: Wrap package ---------------

WrapPackageCheck.name = de.unkrig: Umbruch Package
WrapPackageCheck.desc =\
	Überprüft, dass Package-Deklarationen einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapPackageCheck.wrapDeclBeforePackage = Ob vor dem Schlüsselword "package" umbrochen wird.

# --------------- de.unkrig: Wrap switch block statement group ---------------

WrapSwitchBlockStmtGroupCheck.name = de.unkrig: Umbruch Switch-Block-Statement-Gruppe
WrapSwitchBlockStmtGroupCheck.desc =\
	Überprüft, dass Switch-Block-Statement-Gruppen einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapSwitchBlockStmtGroupCheck.allowOneLineSwitchBlockStmtGroup = Ob die komplette Switch-Block-Statement-Gruppe in einer einzigen Zeile stehen darf.

# --------------- de.unkrig: Wrap TRY statement ---------------

WrapTryCheck.name = de.unkrig: Umbruch TRY-Statement
WrapTryCheck.desc =\
	Überprüft, dass TRY-Statements einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapTryCheck.wrapBeforeCatch             = Ob TRY-Statements vor dem Schlüsselwort "catch" umbrochen werden.
WrapTryCheck.wrapBeforeFinally           = Ob TRY-Statements vor dem Schlüsselwort "finally" umbrochen werden.

# --------------- de.unkrig: Zero-parameter superconstructor invocation ---------------

ZeroParameterSuperconstructorInvocation.name = de.unkrig: Aufruf des parameterlosen Superkonstruktors
ZeroParameterSuperconstructorInvocation.desc =\
	Überprüft, dass kein Konstruktor den parameterlosen Superkonstruktor aufruft:\n\
	<pre>\n\
	class Foo extends Bar {\n\
	\    Foo(int a, int b) {\n\
	\        <font color="red">super();</font>\n\
	\    }\n\
	
	}</pre>\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Entfernen\n\
	\  <dd>Redundanten Aufruf des parameterlosen Superkonstruktors entfernen\n\
	</dl>
