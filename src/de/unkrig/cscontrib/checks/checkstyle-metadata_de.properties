
# This file is maintained by hand and must be kept in sync with "checkstyle-metadata.properties" (without the "_de"
# infix).
# This file must be ISO-8859-1-encoded.

# Rule groups:
Coding.group     = Kodierungsprobleme
Naming.group     = Namenskonventionen
Whitespace.group = Leerraum

# Custom checks, in alphabetical order.

# --------------- de.unkrig: Alignment ---------------

Alignment.name = de.unkrig: Ausrichtung
Alignment.desc =\
	Überprüft, dass Java-Elemente in unmittelbar aufeinanderfolgenden Zeilen (und nur dort!) vertikal ausgerichtet sind:\n\
	<pre>\n\
	public class Main {\n\
	\n\
	\    int    <font color="red">x</font> = 7;\n\
	\    double <font color="red">xxx</font> = 7.0;              // Ausgerichtete Feldnamen\n\
	\n\
	\    int y      <font color="red">=</font> 7;\n\
	\    double yyy <font color="red">=</font> 7.0;              // Ausgerichtete Feld-Initialisierer\n\
	\n\
	\    public static void meth1(\n\
	\        String[] <font color="red">p1</font>,\n\
	\        int      <font color="red">p2</font>                // Ausgerichtete Parameternamen\n\
	\    ) {\n\
	\n\
	\        int    <font color="red">x</font> = 7;\n\
	\        double <font color="red">xxx</font> = 7.0;          // Ausgerichtete lokale Variablennamen\n\
	\n\
	\        int y      <font color="red">=</font> 7;\n\
	\        double yyy <font color="red">=</font> 7.0;          // Ausgerichtete lokale Variablen-Initialisierer\n\
	\n\
	\        y   <font color="red">=</font> 8;\n\
	\        yyy <font color="red">=</font> 8.0;                 // Ausgerichtete Zuweisungen\n\
	\n\
	\        switch (x) {\n\
	\        case 1:  <font color="red">break;</font>\n\
	\        default: <font color="red">x++;</font> return;      // Ausgerichtete Case-Gruppen-Statements\n\
	\        }\n\
	\    }\n\
	\n\
	\    public static void <font color="red">meth2</font>() {}\n\
	\    public void        <font color="red">meth33</font>() {} // Ausgerichtete Methodennamen\n\
	\n\
	\    public static void meth4()  <font color="red">{}</font>\n\
	\    public void meth5()         <font color="red">{}</font> // Ausgerichtete Methodenkörper\n\
	}</pre>
Alignment.applyToFieldName               = Überprüfe die Ausrichtung der ersten Namen in Felddeklarationen.
Alignment.applyToFieldInitializer        = Überprüfe die Ausrichtung der ersten '=' in Felddeklarationen.
Alignment.applyToParameterName           = Überprüfe die Ausrichtung der Methoden-(und Konstruktor-)Parameternamen.
Alignment.applyToLocalVariableName       = Überprüfe die Ausrichtung des ersten namen in lokalen Variablendeklarationen.
Alignment.applyToLocalVariableInitializer = Überprüfe die Ausrichtung der ersten '=' in lokalen Variablendeklarationen.
Alignment.applyToAssignments             = Überprüfe die Ausrichtung des '=' in Zuweisungen.
Alignment.applyToCaseGroupStatements     = Überprüfe die Ausrichtung der ersten Statements in Case-Gruppen.
Alignment.applyToMethodName              = Überprüfe die Ausrichtung der Methoden-(und Konstruktor-)Namen in Deklarationen.
Alignment.applyToMethodBody              = Überprüfe die Ausrichtung des '{' in Methoden-(und Konstruktor-)Deklarationen.

# --------------- de.unkrig: C++-style comment alignment ---------------

CppCommentAlignment.name = de.unkrig: Ausrichtung von C++-Kommentaren
CppCommentAlignment.desc =\
	Überprüft, dass C++-Kommentare ('<code>// ...</code>') korrekt ausgerichtet sind.\n\
	<p>\n\
	C++-Kommentare müssen in derselben Spalte beginnen wenn (und nur wenn)\n\
	<ul>\n\
	\  <li>Sie in unmittelbar aufeinanderfolgenden Zeilen stehen, und\n\
	\  <li>Alle diese Zeilen von derselben 'Art' sind (s.u.)\n\
	</ul>\n\
	Jede Codezeile ist von einer der folgenden 'Arten':\n\
	<ul>\n\
	\  <li>Eine Zeile, die ausschließlichen einen C++-Kommentar enthält\n\
	\  <li>Eine Zeile, die ausschließlich ein SWITCH-Label ('<code>case x:</code>' or '<code>default:</code>') und einen C++-Kommentar enthält\n\
	\  <li>Jede andere Zeile\n\
	</ul>

# --------------- de.unkrig: Inner assignment ---------------

InnerAssignment.name = de.unkrig: Innere Zuweisung
InnerAssignment.desc =\
	Zuweisungen innerhalb von Ausdrücken müssen in Klammern gesetzt werden, etwa "a = (b = c)" oder "while ((a = b))".\n\
	<p>\n\
	\  Dies ist eine Verbesserung von 'InnerAssignment': Es gibt einen Quickfix für ECLIPSE-CS.\n\
	</p>\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zuweisung klammern\n\
	\  <dd>Zuweisung klammern um anzuzeigen dass sie gewollt ist\n\
	</dl>

# --------------- de.unkrig: Name spelling ---------------

NameSpelling.name = de.unkrig: Namensschreibweise
NameSpelling.desc =\
	Überprüft, dass die Namen von Java-Elementen einem bestimmten Muster entsprechen, bzw. <i>nicht</i> entsprechen.\n\
	<p>\n\
	Durch diesen Check wird die Namensschreibweisen-Prüfung leistungsfähiger im Vergleich zu den Standard-"Naming Conventions"-Checks von CheckStyle:\n\
	</p>\n\
	<ul>\n\
	\  <li>Beliebige Kombinationen von erforderlichen/fehlenden Modifiern können angegeben werden</li>\n\
	\  <li>\n\
	\    Namensmuster können nicht nur <i>vorgeschrieben</i>, sondern auch <i>verboten</i> werden (nützlich, um z.B.\n\
	\    bestimmte Stile der "Ungarischen Notation" zu verbieten)\n\
	\  </li>\n\
	\  <li>\n\
	\    Ermöglicht es zusätzlich, die Namen von Annotationen, Annotationsfeldern und <code>enum</code>s zu\n\
	\    überprüfen (was mit den Standard-Checks nicht möglich ist)\n\
	\  </li>\n\
	</ul>\n\
	<p>\n\
	\  Dieser Check löst alle folgenden Standard-"Naming Conventions"-Checks von CheckStyle ab:\n\
	</p>\n\
	<ul>\n\
	\  <li>Abstract Class Name</li>\n\
	\  <li>Class Type Parameter Name</li>\n\
	\  <li>Constant Names</li>\n\
	\  <li>Enum Values Name</li>\n\
	\  <li>Interface Type Parameter Name</li>\n\
	\  <li>Local Final Variable Names</li>\n\
	\  <li>Local Variable Names</li>\n\
	\  <li>Member Names</li>\n\
	\  <li>Method Names</li>\n\
	\  <li>Method Type Parameter Name</li>\n\
	\  <li>Package Names</li>\n\
	\  <li>Parameter Names</li>\n\
	\  <li>Static Variable Names</li>\n\
	\  <li>Type Names</li>\n\
	</ul>
NameSpelling.elements                    = Elemente, auf die der Check angewendet wird.
NameSpelling.requiredModifiers           = Nur auf Elemente mit diesen Modifiern anwenden.
NameSpelling.missingModifiers            = Nur auf Elemente OHNE diese Modifier anwenden.
NameSpelling.option                      = Ob Namen dem Muster entsprechen MÜSSEN oder NICHT ENTSPRECHEN DÜRFEN.
NameSpelling.format                      = Das Muster, das auf die Namen angewendet wird.

# --------------- de.unkrig: Parenthesis padding ---------------

ParenPad.name = de.unkrig: Leerraum um runde Klammern
ParenPad.desc =\
	Verbesserte Version von "ParenPad": NOSPACE lässt nun "<code>( // ...</code>" zu.\n\
	<p>\n\
	\  <span style="color: red"><b>Dieser Check wurde durch "<code>de.unkrig: Whitespace</code>" abgelöst.</b></span>\n\
	</p>
ParenPad.option                          = Ob Leerraum um runde Klammer VORGESCHRIEBEN ist oder VERBOTEN.

# --------------- de.unkrig: Whitespace ---------------

Whitespace.name = de.unkrig: Leerraum
Whitespace.desc =\
	Überprüft, dass vor und/oder nach bestimmten Token Leerraum steht oder <i>nicht</i> steht.\n\
	<p>\n\
	\  Dieser Check löst sowohl alle Standard-CheckStyle-Checks, die Leerraum überprüft, ab\n\
	</p>\n\
	<ul>\n\
	\  <li>Generic Whitespace</li>\n\
	\  <li>Empty For Initializer Pad</li>\n\
	\  <li>Empty For Iterator Pad</li>\n\
	\  <li>No Whitespace After</li>\n\
	\  <li>No Whitespace Before</li>\n\
	\  <li>Method Parameter Pad</li>\n\
	\  <li>Paren Pad</li>\n\
	\  <li>Typecast Paren Pad</li>\n\
	\  <li>Whitespace After</li>\n\
	\  <li>Whitespace Around</li>\n\
	</ul>\n\
	<p>\n\
	\  als auch\n\
	</p>\n\
	<ul>\n\
	\  <li>de.unkrig: Leerraum um runde Klammern</li>\n\
	\  <li>de.unkrig: Leerraum um Token</li>\n\
	</ul>
Whitespace.whitespaceBefore              = Die Java-Elemente, vor denen Leeraum stehen muss (oder ein Zeilenumbruch).
Whitespace.noWhitespaceBefore            = Die Java-Elemente, vor denen kein Leerraum stehen darf (oder die auf einen Zeilenumbruch folgen).
Whitespace.whitespaceAfter               = Die Java-Elemente, nach denen Leeraum stehen muss (oder ein Zeilenumbruch).
Whitespace.noWhitespaceAfter             = Die Java-Elemente, nach denen kein Leerraum stehen darf (oder auf die einen Zeilenumbruch folgen).

# --------------- de.unkrig: Whitespace around ---------------

WhitespaceAround.name = de.unkrig: Leerraum um Token
WhitespaceAround.desc =\
	Überprüft, dass ein Token von Leerraum umgeben ist.\n\
	<p>\n\
	\  <span style="color: red"><b>Dieser Check wurde abgelöst durch "<code>de.unkrig: Leerraum</code>".</b></span>\n\
	</p>\n\
	<p>\n\
	\  Leere Konstruktor-Körper, Method-Körper, CATCH-Blöcke und Typ-Körper in der Form\n\
	</p>\n\
	<pre>\n\
	public MyClass() {}           // Leerer Konstruktor-Körper\n\
	\n\
	public void func() {}         // Leerer Methoden-Körper\n\
	\n\
	public void func() {\n\
	\    new Object() {\n\
	\        // ...\n\
	\    }.hashCode();             // Kein Leerraum zwischen '}' und '.' -- immer erlaubt\n\
	\    try {\n\
	\        // ...\n\
	\    } catch {}                // Leerer CATCH-Block\n\
	}\n\
	\n\
	interface MyInterface {}      // Leerer Typ-Körper\n\
	</pre>\n\
	<p>\n\
	\  können optional von dieser Regel ausgenommen werden mittels der Properties "allowEmptyMethods",\n\
	\  "allowEmptyConstructors", "allowEmptyCatches" und "allowEmptyTypes".\n\
	</p>
WhitespaceAround.tokens                  = Zu überprüfende Token
WhitespaceAround.allowEmptyConstructors  = Lasse leere Konstruktor-Körper zu.
WhitespaceAround.allowEmptyMethods       = Lasse leere methoden-Körper zu.
WhitespaceAround.allowEmptyCatches       = Lasse leere CATCH-Blöcke zu.
WhitespaceAround.allowEmptyTypes         = Lasse leere Typ-Körper zu.
WhitespaceAround.ignoreEnhancedForColon  = Ignore den Doppelpunkt (":") in "Enhanced FOR"-Statements ("for (x : y) ...").

# --------------- de.unkrig: Wrap annotation ---------------

WrapAnnotationCheck.name = de.unkrig: Umbruch Annotationen
WrapAnnotationCheck.desc =\
	Überprüft, dass Annotationen und Annotations-Typ-Deklarationen einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapAnnotationCheck.allowOneLineDecl     = Ob die komplette Deklaration in einer einzigen Zeile stehen darf.
WrapAnnotationCheck.wrapDeclBeforeAt     = Ob die Deklaration vor dem "@" umbrochen wird.
WrapAnnotationCheck.wrapDeclBeforeLCurly = Ob die Deklaration vor der "{" umbrochen wird.
WrapAnnotationCheck.allowMultiplePerLine = Ob mehrere Annotation pro Zeile erlaubt sind.
WrapAnnotationCheck.wrapElementValueArrayInitializerBeforeLCurly = Ob ein Element-Wert-Array-Initialisierer vor der "{" umbrochen wird.
WrapAnnotationCheck.allowMultipleElementValueArrayInitializersPerLine = Ob mehrere Element-Wert-Array-Initialisierer in einer einzigen Zeile stehen dürfen.

# --------------- de.unkrig: Wrap anonymous class ---------------

WrapAnonymousClassCheck.name = de.unkrig: Umbruch anonyme Klassen
WrapAnonymousClassCheck.desc =\
	Überprüft, dass Deklarationen von lokalen Klassen einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapAnonymousClassCheck.wrapDeclBeforeLCurly = Ob Deklarationen anonymer Klasses vor der "{" umbrochen werden.

# --------------- de.unkrig: Wrap array initializer ---------------

WrapArrayInitCheck.name = de.unkrig: Umbruch Array-Initialisierer
WrapArrayInitCheck.desc =\
	Überprüft, dass Array-Initialisierer einheitlich umbrochen und eingerückt sind.\n\
	<p>\n\
	\  Array-Initialisierer treten zwei Arten auf:\n\
	</p>\n\
	<pre>\n\
	// NEW-Ausdruck:\n\
	x = new String[3][4][] { { { "a", "b" } } };\n\
	\n\
	// Feld- oder Lokale-Variablen-Initialisierung:\n\
	String[][] x = { { "a", "b" } };\n\
	</pre>\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapArrayInitCheck.wrapBeforeLCurly      = Ob der Array-Initialisierer vor der "{" umbrochen wird.
WrapArrayInitCheck.allowMultipleValuesPerLine = Ob mehrere Initialisierungswerte pro Zeile erlaubt sind.

# --------------- de.unkrig: Wrap binary operator ---------------

WrapBinaryOperatorCheck.name = de.unkrig: Umbruch Binäre Operatoren
WrapBinaryOperatorCheck.desc =\
	Überprüft, dass binäre Operationen einheitlich vor und/oder nach dem Operator umbrochen sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapBinaryOperatorCheck.wrapBeforeOperator = Ob binäre Ausdrücke VOR dem Operator umbrochen werden.
WrapBinaryOperatorCheck.wrapAfterOperator = Ob binäre Ausdrücke NACH dem Operator umbrochen werden.

# --------------- de.unkrig: Wrap class ---------------

WrapClassCheck.name = de.unkrig: Umbruch Klassen
WrapClassCheck.desc =\
	Überprüft, dass Klassen-Declarationen einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapClassCheck.allowOneLineDecl          = Ob die komplette Deklaration in einer einzigen Zeile stehen darf.
WrapClassCheck.wrapDeclBeforeClass       = Ob vor dem Schlüsselwort "class" umbrochen wird.
WrapClassCheck.wrapDeclBeforeLCurly      = Ob vor der "{" umbrochen wird.

# --------------- de.unkrig: Wrap constructor ---------------

WrapCtorCheck.name = de.unkrig: Umbruch Konstruktoren
WrapCtorCheck.desc =\
	Überprüft, dass Konstructor-Deklarationen, -Parameter and -Argumente einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapCtorCheck.allowOneLineDecl           = Ob eine komplette Konstruktor-Deklaration in einer einzigen Zeile stehen darf.
WrapCtorCheck.wrapDeclBeforeName         = Ob Konstruktor-Deklarationen zwischen den Modifiern und dem Klassennamen umbrochen werden.
WrapCtorCheck.wrapDeclBeforeLCurly       = Ob Konstruktor-Deklarationen vor der "{" umbrochen werden.
WrapCtorCheck.allowMultipleArgsPerLine   = Ob mehrere Konstruktor-Aufruf-Argumente pro Zeile erlaubt sind.
WrapCtorCheck.allowMultipleParametersPerLine = Ob mehrere Konstruktor-Parameter pro Zeile erlaubt sind.

# --------------- de.unkrig: Wrap DO statement ---------------

WrapDoCheck.name = de.unkrig: Umbruch DO-Statement
WrapDoCheck.desc =\
	Überprüft, dass DO-Statements einheitlich umbrochen und eingerückt sind.\n\
	<p>\n\
	\  "Umbrechen vor X" bedeutet, dass direkt vor "X" ein Zeilenumbruch und Leerraum stehen, so dass "X" vertikal\n\
	\  ausgerichtet ist mit dem ersten Token in der unmittelbar darüberstehenden Zeile.\n\
	</p>\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapDoCheck.wrapBeforeLCurly             = Ob DO-Statements vor der "{" umbrochen werden.

# --------------- de.unkrig: Wrap enum ---------------

WrapEnumCheck.name = de.unkrig: Umbruch Enum
WrapEnumCheck.desc =\
	Überprüft, dass Enum-Deklarationen und -Konstanten einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapEnumCheck.allowOneLineDecl           = Ob die komplette Deklaration in einer einzigen Zeile stehen darf.
WrapEnumCheck.wrapDeclBeforeEnum         = Ob enum-Deklarationen vor dem Schlüsselwort "enum" umbrochen werden.
WrapEnumCheck.wrapDeclBeforeLCurly       = Ob enum-Deklarationen vor der "{" umbrochen werden.
WrapEnumCheck.allowMultipleConstantsPerLine = Ob mehrere Enum-Konstanten pro Zeile erlaubt sind.

# --------------- de.unkrig: Wrap field ---------------

WrapFieldCheck.name = de.unkrig: Umbruch Felder
WrapFieldCheck.desc =\
	Überprüft, dass Feld-Deklarationen einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapFieldCheck.wrapDeclBeforeName        = Ob Feld-Deklarationen vor dem Namen umbrochen werden.

# --------------- de.unkrig: Wrap interface ---------------

WrapInterfaceCheck.name = de.unkrig: Umbruch Interface
WrapInterfaceCheck.desc =\
	Überprüft, dass Interface-Deklarationen einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapInterfaceCheck.allowOneLineDecl        = Ob eine komplette Interface-Deklaration in einer einzigen Zeile stehen darf.
WrapInterfaceCheck.wrapDeclBeforeInterface = Ob Interface-Deklarationen vor dem Schlüsselwort "interface" umbrochen werden.
WrapInterfaceCheck.wrapDeclBeforeLCurly    = Ob Interface-Deklarationen vor der "{" umbrochen werden.

# --------------- de.unkrig: Wrap local variable ---------------

WrapLocalVariableCheck.name = de.unkrig: Umbruch lokale Variable
WrapLocalVariableCheck.desc =\
	Überprüft, dass Deklarationen von lokalen Variablen einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapLocalVariableCheck.wrapDeclBeforeName = Ob Lokale-Variablen-Deklarationen zwischen dem Typ und dem Variablennamen umbrochen werden.

# --------------- de.unkrig: Wrap method ---------------

WrapMethodCheck.name = de.unkrig: Umbruch Methode
WrapMethodCheck.desc =\
	Überprüft, dass Methoden-Deklarationen, -Parameter und Aufruf-Argumente einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapMethodCheck.allowOneLineDecl         = Ob eine komplette Methoden-Deklaration in einer einzigen Zeile stehen darf.
WrapMethodCheck.wrapDeclBeforeName       = Ob Methoden-Deklarationen zwischen dem Rückgabe-Typ und dem Methodennamen umbrochen werden.
WrapMethodCheck.wrapMethodDeclBeforeLCurly = Ob Methoden-Deklarationen vor der "{" umbrochen werden.
WrapMethodCheck.allowMultipleArgsPerLine = Ob mehrere Methoden-Aufruf-Argumente pro Zeile erlaubt sind.
WrapMethodCheck.allowMultipleParametersPerLine = Ob mehrere Methoden-Parameter-Deklarationen pro Zeile erlaubt sind.

# --------------- de.unkrig: Wrap package ---------------

WrapPackageCheck.name = de.unkrig: Umbruch Package
WrapPackageCheck.desc =\
	Überprüft, dass Package-Deklarationen einheitlich umbrochen und eingerückt sind.\n\
	<p>\n\
	\  "Umbrechen vor X" bedeutet, dass direkt vor "X" ein Zeilenumbruch und Leerraum stehen, so dass "X" vertikal\n\
	\  ausgerichtet ist mit dem ersten Token in der unmittelbar darüberstehenden Zeile.\n\
	</p>\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapPackageCheck.wrapDeclBeforePackage   = Ob Package-Deklarationen vor dem Schlüsselword "package" umbrochen werden.

# --------------- de.unkrig: Wrap switch block statement group ---------------

WrapSwitchBlockStmtGroupCheck.name = de.unkrig: Umbruch Switch-Block-Statement-Gruppe
WrapSwitchBlockStmtGroupCheck.desc =\
	Überprüft, dass Switch-Block-Statement-Gruppen einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapSwitchBlockStmtGroupCheck.allowOneLineSwitchBlockStmtGroup = Ob eine komplette Switch-Block-Statement-Gruppe in einer einzigen Zeile stehen darf.

# --------------- de.unkrig: Wrap TRY statement ---------------

WrapTryCheck.name = de.unkrig: Umbruch TRY-Statement
WrapTryCheck.desc =\
	Überprüft, dass TRY-Statements einheitlich umbrochen und eingerückt sind.\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Zeile umbrechen\n\
	\  <dd>Diese Zeile an der richtigen Stelle umbrechen\n\
	\  <dt>Zeilen verbinden\n\
	\  <dd>Diese Zeile mit der vorangehenden verbinden\n\
	\  <dt>Einrückung korrigieren\n\
	\  <dd>Einrückung dieser Zeile korrigieren\n\
	</dl>
WrapTryCheck.wrapBeforeResourceSpecification = Ob TRY-mit-Ressourcen-Statements vor der öffnenden geschweiften Klammer der Ressource-Spezifikation umbrochen werden.
WrapTryCheck.wrapBeforeCatch             = Ob TRY-Statements vor dem Schlüsselwort "catch" umbrochen werden.
WrapTryCheck.wrapBeforeBody              = Ob TRY-Statements vor dem Körper umbrochen werden..
WrapTryCheck.wrapBeforeFinally           = Ob TRY-Statements vor dem Schlüsselwort "finally" umbrochen werden.

# --------------- de.unkrig: Zero-parameter superconstructor invocation ---------------

ZeroParameterSuperconstructorInvocation.name = de.unkrig: Aufruf des parameterlosen Superkonstruktors
ZeroParameterSuperconstructorInvocation.desc =\
	Überprüft, dass kein Konstruktor den parameterlosen Superkonstruktor aufruft:\n\
	<pre>\n\
	class Foo extends Bar {\n\
	\    Foo(int a, int b) {\n\
	\        <font color="red">super();</font>\n\
	\    }\n\
	}</pre>\n\
	\n\
	<h4>Quickfixe:</h4>\n\
	<dl>\n\
	\  <dt>Entfernen\n\
	\  <dd>Redundanten Aufruf des parameterlosen Superkonstruktors entfernen\n\
	</dl>
