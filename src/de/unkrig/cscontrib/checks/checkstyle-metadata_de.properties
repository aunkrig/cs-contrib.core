
# Rule groups:
Coding.group     = Kodierungsprobleme
Naming.group     = Namenskonventionen
Whitespace.group = Leerraum

# Custom checks, in alphabetical order.

# --------------- de.unkrig: Alignment ---------------

de.unkrig.cscontrib.checks.Alignment.name = de.unkrig: Ausrichtung
de.unkrig.cscontrib.checks.Alignment.desc =\
	Überprüft, dass Java-Elemente in unmittelbar aufeinanderfolgenden Zeilen (und nur dort!) vertikal ausgerichtet sind:\n\
	<pre>\n\
	public class Main {\n\
	\n\
	\    int    <font color="red">x</font> = 7;\n\
	\    double <font color="red">xxx</font> = 7.0;              // Ausgerichtete Feldnamen\n\
	\n\
	\    int y      <font color="red">=</font> 7;\n\
	\    double yyy <font color="red">=</font> 7.0;              // Ausgerichtete Feld-Initialisierer\n\
	\n\
	\    public static void meth1(\n\
	\        String[] <font color="red">p1</font>,\n\
	\        int      <font color="red">p2</font>                // Ausgerichtete Parameternamen\n\
	\    ) {\n\
	\n\
	\        int    <font color="red">x</font> = 7;\n\
	\        double <font color="red">xxx</font> = 7.0;          // Ausgerichtete lokale Variablennamen\n\
	\n\
	\        int y      <font color="red">=</font> 7;\n\
	\        double yyy <font color="red">=</font> 7.0;          // Ausgerichtete lokale Variablen-Initialisierer\n\
	\n\
	\        y   <font color="red">=</font> 8;\n\
	\        yyy <font color="red">=</font> 8.0;                 // Ausgerichtete Zuweisungen\n\
	\n\
	\        switch (x) {\n\
	\        case 1:  <font color="red">break;</font>\n\
	\        default: <font color="red">x++;</font> return;      // Ausgerichtete Case-Gruppen-Statements\n\
	\        }\n\
	\    }\n\
	\n\
	\    public static void <font color="red">meth2</font>() {}\n\
	\    public void        <font color="red">meth33</font>() {} // Ausgerichtete Methodennamen\n\
	\n\
	\    public static void meth4()  <font color="red">{}</font>\n\
	\    public void meth5()         <font color="red">{}</font> // Ausgerichtete Methodenkörper\n\
	}</pre>
de.unkrig.cscontrib.checks.Alignment.applyToFieldName                = Überprüfe die Ausrichtung der ersten Namen in Felddeklarationen.
de.unkrig.cscontrib.checks.Alignment.applyToFieldInitializer         = Überprüfe die Ausrichtung der ersten '=' in Felddeklarationen.
de.unkrig.cscontrib.checks.Alignment.applyToParameterName            = Überprüfe die Ausrichtung der Methoden-(und Konstruktor-)Parameternamen.
de.unkrig.cscontrib.checks.Alignment.applyToLocalVariableName        = Überprüfe die Ausrichtung des ersten namen in lokalen Variablendeklarationen.
de.unkrig.cscontrib.checks.Alignment.applyToLocalVariableInitializer = Überprüfe die Ausrichtung der ersten '=' in lokalen Variablendeklarationen.
de.unkrig.cscontrib.checks.Alignment.applyToAssignments              = Überprüfe die Ausrichtung des '=' in Zuweisungen.
de.unkrig.cscontrib.checks.Alignment.applyToCaseGroupStatements      = Überprüfe die Ausrichtung der ersten Statements in Case-Gruppen.
de.unkrig.cscontrib.checks.Alignment.applyToMethodName               = Überprüfe die Ausrichtung der Methoden-(und Konstruktor-)Namen in Deklarationen.
de.unkrig.cscontrib.checks.Alignment.applyToMethodBody               = Überprüfe die Ausrichtung des '{' in Methoden-(und Konstruktor-)Deklarationen.

# --------------- de.unkrig: C++-style comment alignment ---------------

de.unkrig.cscontrib.checks.CppCommentAlignment.name = de.unkrig: Ausrichtung von C++-Kommentaren
de.unkrig.cscontrib.checks.CppCommentAlignment.desc =\
	Überprüft, dass C++-Kommentare ('<code>// ...</code>') korrekt ausgerichtet sind.\n\
	<p>\n\
	C++-Kommentare müssen in derselben Spalte beginnen wenn (und nur wenn)\n\
	<ul>\n\
	\  <li>Sie in unmittelbar aufeinanderfolgenden Zeilen stehen, und\n\
	\  <li>Alle diese Zeilen von derselben 'Art' sind (s.u.)\n\
	</ul>\n\
	Jede Codezeile ist von einer der folgenden 'Arten':\n\
	<ul>\n\
	\  <li>Eine Zeile, die ausschließlichen einen C++-Kommentar enthält\n\
	\  <li>Eine Zeile, die ausschließlich ein SWITCH-Label ('<code>case x:</code>' or '<code>default:</code>') und einen C++-Kommentar enthält\n\
	\  <li>Jede andere Zeile\n\
	</ul>

# --------------- de.unkrig: Inner assignment ---------------

de.unkrig.cscontrib.checks.InnerAssignment.name = de.unkrig: Innere Zuweisung
de.unkrig.cscontrib.checks.InnerAssignment.desc =\
	Zuweisungen innerhalb von Ausdrücken müssen in Klammern gesetzt werden, etwa "a = (b = c)" oder "while ((a = b))".\n\
	<p>\n\
	\  Dies ist eine Verbesserung von 'InnerAssignment': Es gibt einen Quickfix für ECLIPSE-CS.\n\
	</p>\n\
	\n\
	Quickfixe sind für diesen Check verfügbar.

# --------------- de.unkrig: Name spelling ---------------

de.unkrig.cscontrib.checks.NameSpelling.name = de.unkrig: Namensschreibweise
de.unkrig.cscontrib.checks.NameSpelling.desc =\
	Überprüft, dass die Namen von Java-Elementen einen bestimmten Muster entsprechen, bzw. <i>nicht</i> entsprechen.\n\
	<p>\n\
	Durch diesen Check wird die Namensschreibweisen-Prüfung leistungsfähiger im Vergleich zu den Standard-"Naming\n\
	Conventions"-Checks von CheckStyle:\n\
	</p>\n\
	<ul>\n\
	\  <li>Beliebige Kombinationen von erforderlichen/fehlenden Modifiern können angegeben werden</li>\n\
	\  <li>\n\
	\    Namensmuster können nicht nur <i>vorgeschrieben</i>, sondern auch <i>verboten</i> werden (nützlich, um z.B.\n\
	\    bestimmte Stile der "Ungarischen Notation" zu verbieten)\n\
	\  </li>\n\
	\  <li>\n\
	\    Ermöglicht es zusätzlich, die Namen von Annotationen, Annotationsfeldern und <code>enum</code>s zu\n\
	\    überprüfen (was mit den Standard-Checks nicht möglich ist)\n\
	\  </li>\n\
	</ul>\n\
	<p>\n\
	\  Dieser Check löst alle folgenden Standard-"Naming Conventions"-Checks von CheckStyle ab:\n\
	</p>\n\
	<ul>\n\
	\  <li>Abstract Class Name</li>\n\
	\  <li>Class Type Parameter Name</li>\n\
	\  <li>Constant Names</li>\n\
	\  <li>Enum Values Name</li>\n\
	\  <li>Interface Type Parameter Name</li>\n\
	\  <li>Local Final Variable Names</li>\n\
	\  <li>Local Variable Names</li>\n\
	\  <li>Member Names</li>\n\
	\  <li>Method Names</li>\n\
	\  <li>Method Type Parameter Name</li>\n\
	\  <li>Package Names</li>\n\
	\  <li>Parameter Names</li>\n\
	\  <li>Static Variable Names</li>\n\
	\  <li>Type Names</li>\n\
	</ul>
de.unkrig.cscontrib.checks.NameSpelling.elements          = Elemente, auf die der Check angewendet wird.
de.unkrig.cscontrib.checks.NameSpelling.requiredModifiers = Nur auf Elemente mit diesen Modifiern anwenden.
de.unkrig.cscontrib.checks.NameSpelling.missingModifiers  = Nur auf Elemente <i>ohne</i> diese Modifier anwenden.
de.unkrig.cscontrib.checks.NameSpelling.option            = Ob Namen dem Muster entsprechen <i>müssen</i> oder <i>nicht entsprechen dürfen</i>.
de.unkrig.cscontrib.checks.NameSpelling.format            = Das Muster, das auf die Namen angewendet wird.

# --------------- de.unkrig: Parenthesis padding ---------------

de.unkrig.cscontrib.checks.ParenPad.name = de.unkrig: Leerraum um runde Klammern
de.unkrig.cscontrib.checks.ParenPad.desc =\
	Verbesserte version von "ParenPad": NOSPACE lässt nun "<code>( // ...</code>" zu.\n\
	<p>\n\
	\  <span style="color: red"><b>Dieser Check wurde durch "<code>de.unkrig: Whitespace</code>" abgelöst.</b></span>\n\
	</p>
de.unkrig.cscontrib.checks.ParenPad.option = Ob Leerraum um runde Klammer <i>vorgeschrieben</i> ist oder <i>verboten</i>.
de.unkrig.cscontrib.checks.ParenPad.tokens = Zu überprüfende Token.

# --------------- de.unkrig: Whitespace ---------------

de.unkrig.cscontrib.checks.Whitespace.name = de.unkrig: Leerraum
de.unkrig.cscontrib.checks.Whitespace.desc =\
	Überprüft, dass vor und/oder nach bestimmten Token Leerraum steht oder <i>nicht</i> steht.\n\
	<p>\n\
	\  Dieser Check löst sowohl alle Standard-CheckStyle-Checks, die Leerraum überprüft, ab\n\
	</p>\n\
	<ul>\n\
	\  <li>Generic Whitespace</li>\n\
	\  <li>Empty For Initializer Pad</li>\n\
	\  <li>Empty For Iterator Pad</li>\n\
	\  <li>No Whitespace After</li>\n\
	\  <li>No Whitespace Before</li>\n\
	\  <li>Method Parameter Pad</li>\n\
	\  <li>Paren Pad</li>\n\
	\  <li>Typecast Paren Pad</li>\n\
	\  <li>Whitespace After</li>\n\
	\  <li>Whitespace Around</li>\n\
	</ul>\n\
	<p>\n\
	\  als auch\n\
	</p>\n\
	<ul>\n\
	\  <li>de.unkrig: Leerraum um runde Klammern</li>\n\
	\  <li>de.unkrig: Leerraum um Token</li>\n\
	</ul>
de.unkrig.cscontrib.checks.Whitespace.whitespaceBefore   = Die Java-Elemente, vor denen Leeraum stehen muss (oder ein Zeilenumbruch).
de.unkrig.cscontrib.checks.Whitespace.noWhitespaceBefore = Die Java-Elemente, vor denen kein Leerraum stehen darf (oder die auf einen Zeilenumbruch folgen).
de.unkrig.cscontrib.checks.Whitespace.whitespaceAfter    = Die Java-Elemente, nach denen Leeraum stehen muss (oder ein Zeilenumbruch).
de.unkrig.cscontrib.checks.Whitespace.noWhitespaceAfter  = Die Java-Elemente, nach denen kein Leerraum stehen darf (oder auf die einen Zeilenumbruch folgen).

# --------------- de.unkrig: Whitespace around ---------------

de.unkrig.cscontrib.checks.WhitespaceAround.name = de.unkrig: Leerraum um Token
de.unkrig.cscontrib.checks.WhitespaceAround.desc =\
	Überprüft, dass ein Token von Leerraum umgeben ist.\n\
	<p>\n\
	\  <span style="color: red"><b>Dieser Check wurde abgelöst durch "<code>de.unkrig: Leerraum</code>".</b></span>\n\
	</p>\n\
	<p>\n\
	\  Leere Konstruktor-Körper, Method-Körper, CATCH-Blöcke und Typ-Körper in der Form\n\
	</p>\n\
	<pre>\n\
	public MyClass() {}           // Leerer Konstruktor-Körper\n\
	\n\
	public void func() {}         // Leerer Methoden-Körper\n\
	\n\
	public void func() {\n\
	\    new Object() {\n\
	\        // ...\n\
	\    }.hashCode();             // Kein Leerraum zwischen '}' und '.' -- immer erlaubt\n\
	\    try {\n\
	\        // ...\n\
	\    } catch {}                // Leerer CATCH-Block\n\
	}\n\
	\n\
	interface MyInterface {}       // Leerer Typ-Körper\n\
	</pre>\n\
	<p>\n\
	\  können optional von dieser Regel ausgenommen werden mittels der Properties "allowEmptyMethods",\n\
	\  "allowEmptyConstructors", "allowEmptyCatches" und "allowEmptyTypes".\n\
	</p>
de.unkrig.cscontrib.checks.WhitespaceAround.tokens                   = Zu überprüfende Token
de.unkrig.cscontrib.checks.WhitespaceAround.allowEmptyConstructors   = Lasse leere Konstruktor-Körper zu.
de.unkrig.cscontrib.checks.WhitespaceAround.allowEmptyMethods        = Lasse leere methoden-Körper zu.
de.unkrig.cscontrib.checks.WhitespaceAround.allowEmptyCatches        = Lasse leere CATCH-Blöcke zu.
de.unkrig.cscontrib.checks.WhitespaceAround.allowEmptyTypes          = Lasse leere Typ-Körper zu.
de.unkrig.cscontrib.checks.WhitespaceAround.ignoreEnhancedForColon   = Ignore den Doppelpunkt (":") im "Enhanced FOR"-Statment ("{@code for (x : y) ...}").

# --------------- de.unkrig: Wrap and indent ---------------

de.unkrig.cscontrib.checks.WrapAndIndent.name = de.unkrig: Umbruch und Einrückung
de.unkrig.cscontrib.checks.WrapAndIndent.desc =\
	Überprüft, dass Statements einheitlich umbrochen und eingerückt sind.\n\
	<p>\n\
	\  <b>Dieser Check löst folgende Checks ab:</b>\n\
	</p>\n\
	<ul style="color: red">\n\
	\  <li>Left curly brace placement</li>\n\
	\  <li>Right curly brace placement</li>\n\
	\  <li>Operator wrap</li>\n\
	</ul>\n\
	\n\
	Quickfixe für diesen Check sind verfügbar.
de.unkrig.cscontrib.checks.WrapAndIndent.basicOffset                      = Anzahl Leerzeilen pro Einrückungsebene.
de.unkrig.cscontrib.checks.WrapAndIndent.allowOneLineClassDecl            = Ob einzeilige Klassendeklarationen erlaubt sind.
de.unkrig.cscontrib.checks.WrapAndIndent.allowOneLineInterfaceDecl        = Ob einzeilige Interfacedeklarationen erlaubt sind.
de.unkrig.cscontrib.checks.WrapAndIndent.allowOneLineEnumDecl             = Ob einzeilige {@ code enum}-Deklarationen erlaubt sind.
de.unkrig.cscontrib.checks.WrapAndIndent.allowOneLineAnnoDecl             = Ob einzeilige Annotationsdeklarationen erlaubt sind.
de.unkrig.cscontrib.checks.WrapAndIndent.allowOneLineCtorDecl             = Ob einzeilige Konstruktordeklarationen erlaubt sind.
de.unkrig.cscontrib.checks.WrapAndIndent.allowOneLineMethDecl             = Ob einzeilige Methodendeklarationen erlaubt sind.
de.unkrig.cscontrib.checks.WrapAndIndent.allowOneLineSwitchBlockStmtGroup = Ob einzeilige {@code switch}-Block-Statement-Gruppen erlaubt sind
de.unkrig.cscontrib.checks.WrapAndIndent.wrapPackageDeclBeforePackage     = Ob Package-Deklarationen (in "{@code package-info.java}") vor dem Schlüsselwort '{@code package}' umbrochen werden
de.unkrig.cscontrib.checks.WrapAndIndent.wrapClassDeclBeforeClass         = Ob Klassendeklarationen vor dem Schlüsselwort '{@code class}' umbrochen werden
de.unkrig.cscontrib.checks.WrapAndIndent.wrapInterfaceDeclBeforeInterface = Ob Interfacedeklarationen vor dem Schlüsselwort '{@code interface}' umbrochen werden
de.unkrig.cscontrib.checks.WrapAndIndent.wrapEnumDeclBeforeEnum           = Ob {@code enum}-Deklarationen vor dem Schlüsselwort '{@code enum}' umbrochen werden
de.unkrig.cscontrib.checks.WrapAndIndent.wrapAnnoDeclBeforeAt             = Ob Annotations-Deklarations vor dem '@' umbrochen werden
de.unkrig.cscontrib.checks.WrapAndIndent.wrapFieldDeclBeforeName          = Ob Felddeklarationen vor dem Feldnamen umbrochen werden
de.unkrig.cscontrib.checks.WrapAndIndent.wrapCtorDeclBeforeName           = Ob Konstruktordeklarationen zwischen den Modifiern und dem Klassennamen umbrochen werden
de.unkrig.cscontrib.checks.WrapAndIndent.wrapMethDeclBeforeName           = Ob Methodendeklarationen zwischen dem Rückgabetyp und dem und dem Methodennamen umbrochen werden
de.unkrig.cscontrib.checks.WrapAndIndent.wrapLocVarDeclBeforeName         = Ob lokale Variablendeklarationen zwischen dem Typ und dem Variablennamen umbrochen werden
de.unkrig.cscontrib.checks.WrapAndIndent.wrapTypeDeclBeforeLCurly         = Ob Typdeklarationen vor der öffnenden geschweiften Klammer umbrochen werden
de.unkrig.cscontrib.checks.WrapAndIndent.wrapCtorDeclBeforeLCurly         = Ob Konstruktordeklarationen vor der öffnenden geschweiften Klammer umbrochen werden
de.unkrig.cscontrib.checks.WrapAndIndent.wrapMethodDeclBeforeLCurly       = Ob Methodendeklarationen vor der öffnenden geschweiften Klammer umbrochen werden
de.unkrig.cscontrib.checks.WrapAndIndent.wrapAnonClassDeclBeforeLCurly    = Ob anonyme Klassendeklarationen vor der öffnenden geschweiften Klammer umbrochen werden
de.unkrig.cscontrib.checks.WrapAndIndent.wrapDoBeforeLCurly               = Ob {@code do}-Statements vor der öffnenden geschweiften Klammer umbrochen werden
de.unkrig.cscontrib.checks.WrapAndIndent.wrapTryBeforeCatch               = Ob {@code try}-Statements vor dem Schlüsselwort '{@code catch}' umbrochen werden
de.unkrig.cscontrib.checks.WrapAndIndent.wrapTryBeforeFinally             = Ob {@code try}-Statements vor dem Schlüsselwort '{@code finally}' umbrochen werden
de.unkrig.cscontrib.checks.WrapAndIndent.wrapArrayInitBeforeLCurly        = Ob Array-Initialisierer vor der öffnenden geschweiften Klammer umbrochen werden
de.unkrig.cscontrib.checks.WrapAndIndent.wrapBeforeBinaryOperator         = Ob Ausdrücke vor binären Operatoren umbrochen werden
de.unkrig.cscontrib.checks.WrapAndIndent.wrapAfterBinaryOperator          = Ob Ausdrücke nach binären Operatoren umbrochen werden

# --------------- de.unkrig: Zero-parameter superconstructor invocation ---------------

de.unkrig.cscontrib.checks.ZeroParameterSuperconstructorInvocation.name = de.unkrig: Aufruf des parameterlosen Superkonstruktors
de.unkrig.cscontrib.checks.ZeroParameterSuperconstructorInvocation.desc =\
	Überprüft, dass kein Konstruktor den parameterlosen Superkonstruktor aufruft:\n\
	<pre>\n\
	class Foo extends Bar {\n\
	\    Foo(int a, int b) {\n\
	\        <font color="red">super();</font>\n\
	\    }\n\
	}</pre>\n\
	\n\
	Quickfixe sind für diesen Check verfügbar.
