
# Groups of checks.
Naming.group     = Naming Conventions
Coding.group     = Coding Problems
Other.group      = Other
Whitespace.group = Whitespace
Filters.group    = Filters

# Custom checks, in alphabetical order.

# --------------- de.unkrig.Alignment ---------------

de.unkrig.cscontrib.checks.Alignment.name = de.unkrig.Alignment
de.unkrig.cscontrib.checks.Alignment.desc =\
	Verifies that Java elements are vertically aligned in immediately consecutive lines (and only there\!):\
	<pre>\
	\    public class Main {\n\
	\n\
	\        int    <font color="red">x</font> = 7;\n\
	\        double <font color="red">xxx</font> = 7.0;              // Aligned field names\n\
	\n\
	\        int y      <font color="red">=</font> 7;\n\
	\        double yyy <font color="red">=</font> 7.0;              // Aligned field initializers\n\
	\n\
	\        public static void meth1(\n\
	\            String[] <font color="red">p1</font>,\n\
	\            int      <font color="red">p2</font>                // Aligned parameter names\n\
	\        ) {\n\
	\n\
	\            int    <font color="red">x</font> = 7;\n\
	\            double <font color="red">xxx</font> = 7.0;          // Aligned local variable names\n\
	\n\
	\            int y      <font color="red">=</font> 7;\n\
	\            double yyy <font color="red">=</font> 7.0;          // Aligned local variable initializers\n\
	\n\
	\            y   <font color="red">=</font> 8;\n\
	\            yyy <font color="red">=</font> 8.0;                 // Aligned assignments\n\
	\n\
	\            switch (x) {\n\
	\            case 1:  <font color="red">break;</font>\n\
	\            default: <font color="red">x++;</font> return;      // Aligned case groups statements\n\
	\            }\n\
	\        }\n\
	\n\
	\        public static void <font color="red">meth2</font>()  <font color="red">{}</font>\n\
	\        public void        <font color="red">meth33</font>() <font color="red">{}</font> // Aligned method names and bodies\n\
	\    }</pre>
de.unkrig.cscontrib.checks.Alignment.applyToFieldName                = Check alignment of field names in declarations.
de.unkrig.cscontrib.checks.Alignment.applyToFieldInitializer         = Check alignment of '=' in field declarations.
de.unkrig.cscontrib.checks.Alignment.applyToLocalVariableName        = Check alignment of local variable names in declarations.
de.unkrig.cscontrib.checks.Alignment.applyToLocalVariableInitializer = Check alignment of '=' in local variable declarations.
de.unkrig.cscontrib.checks.Alignment.applyToParameterName            = Check alignment of constructor and method parameter names.
de.unkrig.cscontrib.checks.Alignment.applyToMethodName               = Check alignment of method (and constructor) names in declarations.
de.unkrig.cscontrib.checks.Alignment.applyToMethodBody               = Check alignment of '{' in method (and constructor) declarations.
de.unkrig.cscontrib.checks.Alignment.applyToCaseGroupStatements      = Check alignment of first statement in case groups.
de.unkrig.cscontrib.checks.Alignment.applyToAssignments              = Check alignment of '=' in assignments.

# --------------- de.unkrig.CppCommentAlignment ---------------

de.unkrig.cscontrib.checks.CppCommentAlignment.name = de.unkrig.CppCommentAlignment
de.unkrig.cscontrib.checks.CppCommentAlignment.desc =\
	Verifies that C++ comments are correctly aligned.\
	<p>\
	C++ comments must appear on the same column iff\
	<ul>\
	  <li>They designate AST siblings, and\
	  <li>They appear in immediately consecutive lines\
	</ul>\
	Examples for AST siblings are the arguments in an invocation, or the operands of an arithmetic expression.

# --------------- de.unkrig.InnerAssignment ---------------

de.unkrig.cscontrib.checks.InnerAssignment.name = de.unkrig.InnerAssignment
de.unkrig.cscontrib.checks.InnerAssignment.desc = Assignments in expressions must be parenthesized.

# --------------- de.unkrig.NameSpelling ---------------

de.unkrig.cscontrib.checks.NameSpelling.name = de.unkrig.NameSpelling
de.unkrig.cscontrib.checks.NameSpelling.desc = Whether the names of Java elements match a given pattern.
de.unkrig.cscontrib.checks.NameSpelling.elements          = Elements to apply this check to
de.unkrig.cscontrib.checks.NameSpelling.requiredModifiers = Apply only to declarations which have these modifiers
de.unkrig.cscontrib.checks.NameSpelling.missingModifiers  = Apply only to declarations which do not have these modifiers
de.unkrig.cscontrib.checks.NameSpelling.option            = Whether to REQUIRE or FORBID that names match
de.unkrig.cscontrib.checks.NameSpelling.format            = Pattern to match the name against

# --------------- de.unkrig.ParenPad ---------------

de.unkrig.cscontrib.checks.ParenPad.name = de.unkrig.ParenPad
de.unkrig.cscontrib.checks.ParenPad.desc =\
	Enhanced version of "ParenPad": NOSPACE now allows '( // ...'.\
	<p>\
	<b>This check is superseded by 'de.unkrig.Whitespace'.</b>
de.unkrig.cscontrib.checks.ParenPad.option = Whether space is required or forbidding
de.unkrig.cscontrib.checks.ParenPad.tokens = Tokens to check

# --------------- de.unkrig.Whitespace ---------------

de.unkrig.cscontrib.checks.Whitespace.name = de.unkrig.Whitespace
de.unkrig.cscontrib.checks.Whitespace.desc =\
	Whether tokens are (or are not) preceded with (and/or followed by) whitespace.\
	<p>\
	This check supersedes all of CheckStyle's whitespace-related checks:\
	<ul>\
	  <li>Generic Whitespace\
	  <li>Empty For Initializer Pad\
	  <li>Empty For Iterator Pad\
	  <li>No Whitespace After\
	  <li>No Whitespace Before\
	  <li>Method Parameter Pad\
	  <li>Paren Pad\
	  <li>Typecast Paren Pad\
	  <li>Whitespace After\
	  <li>Whitespace Around\
	</ul>\
	, as well as\
	<ul>\
	  <li>de.unkrig.ParenPad\
	  <li>de.unkrig.WhitespaceAround\
	</ul>\
	.\
	<p>\
	The options of the four properties represent the Java tokens. \
	If a token can appear in different contexts, then it appears as multiple options, with two underscores and the \
	context appended to its name.\
	<dl>\
	  <dt>abstract\
	  <dd><font color="red">abstract</font>\
	  <dt>and__expr\
	  <dd>a <font color="red">&amp;</font> b\
	  <dt>and__type_bound\
	  <dd>&lt;T extends MyClass <font color="red">&amp;</font> MyInterface>\
	  <dt>and_assign\
	  <dd>a <font color="red">&amp;=</font> b\
      <dt>assert\
      <dd><font color="red">assert</font> x == 0;<br/><font color="red">assert</font> x == 0 : "x not zero";\
      <dt>assign__assignment\
      <dd>a <font color="red">=</font> 7;\
      <dt>assign__var_decl\
      <dd>int a <font color="red">=</font> 7;\
      <dt>at__anno\
      <dd><font color="red">@</font>MyAnno\
      <dt>at__anno_decl\
      <dd>interface <font color="red">@</font>MyAnno {\
      <dt>bitwise_complement\
      <dd><font color="red">~</font>a\
      <dt>boolean\
      <dd><font color="red">boolean</font>\
      <dt>break\
      <dd><font color="red">break</font>;<br/><font color="red">break</font> LABEL;\
      <dt>byte\
      <dd><font color="red">byte</font>\
      <dt>case\
      <dd><font color="red">case</font> 7:\
      <dt>catch\
      <dd><font color="red">catch</font> (Exception e) {\
      <dt>char\
      <dd><font color="red">char</font>\
      <dt>char_literal\
      <dd><font color="red">'c'</font>\
      <dt>class__class_decl\
      <dd><font color="red">class</font> MyClass {\
      <dt>class__class_literal\
      <dd>Class c = Object.<font color="red">class</font>;\
      <dt>colon__case\
      <dd>case 77<font color="red">:</font>\
      <dt>colon__default\
      <dd>default<font color="red">:</font>\
      <dt>colon__enhanced_for\
      <dd>for (Object o <font color="red">:</font> list) {\
      <dt>colon__labeled_stat\
      <dd>LABEL<font color="red">:</font> while (...) {\
      <dt>colon__ternary\
      <dd>a ? b <font color="red">:</font> c\
      <dt>comma\
      <dd><font color="red">,</font>\
      <dt>conditional_and\
      <dd>a <font color="red">&&</font> b\
      <dt>conditional_or\
      <dd>a <font color="red">||</font> b\
      <dt>continue\
      <dd><font color="red">continue</font>;<br/><font color="red">continue</font> LABEL;\
      <dt>default__anno_elem\
      <dd>interface @MyAnno { String engineer() <font color="red">default</font> "[unassigned]"; }\
      <dt>default__switch\
      <dd>switch (x) { <font color="red">default</font>: break; }\
      <dt>divide\
      <dd>a <font color="red">/</font> b\
      <dt>do\
      <dd>a <font color="red">/=</font> b\
      <dt>divide_assign\
      <dd><font color="red">do</font> { ... } while (...);\
      <dt>dot__import\
      <dd>import pkg<font color="red">.</font>*;<br/>import pkg<font color="red">.</font>Type;\
      <dt>dot__package_decl\
      <dd>package pkg<font color="red">.</font>pkg;\
      <dt>dot__qualified_type\
      <dd>pkg<font color="red">.</font>MyType<br/>pkg<font color="red">.</font>MyType[]\
      <dt>dot__selector\
      <dd>a<font color="red">.</font>b<br/>a<font color="red">.</font>b()\
      <dt>double\
      <dd><font color="red">double</font>\
      <dt>double_literal\
      <dd>\
        <font color="red">1.0</font><br/>\
        <font color="red">.1</font><br/>\
        <font color="red">1E3</font><br/>\
        <font color="red">1D</font>\
      <dt>ellipsis\
      <dd>meth(Object<font color="red">...</font> o)\
      <dt>else\
      <dd>if (...) { ... } <font color="red">else</font> { ... }\
      <dt>enum\
      <dd>public <font color="red">enum</font> Color { RED, BLUE, GREEN }\
      <dt>equal\
      <dd>a <font color="red">==</font> b\
      <dt>extends__type\
      <dd>class MyClass <font color="red">extends</font> BaseClass {\
      <dt>extends__type_bound\
      <dd>List&lt;T <font color="red">extends</font> MyClass>\
      <dt>false\
      <dd><font color="red">false</font>\
      <dt>final\
      <dd><font color="red">final</font>\
      <dt>finally\
      <dd>try { ... } <font color="red">finally</font> { ... }\
      <dt>float\
      <dd><font color="red">float</font>\
      <dt>float_literal\
      <dd><font color="red">1F</font>\
      <dt>for\
      <dd>\
        <font color="red">for</font> (int i = 0; i < 3; i++) {<br/>\
        <font color="red">for</font> (Object o : list) {\
      <dt>greater\
      <dd>a <font color="red">></font> b\
      <dt>greater_equal\
      <dd>a <font color="red">>=</font> b\
      <dt>if\
      <dd><font color="red">if</font> (a == 0) {\
      <dt>implements\
      <dd>List&lt;T <font color="red">implements</font> MyInterface1, MyInterface2>\
      <dt>import\
      <dd><font color="red">import</font> pkg.MyClass;<br/><font color="red">import</font> pkg.*;\
      <dt>import__static_import\
      <dd>\
        <font color="red">import</font> static pkg.MyClass.member;<br/>\
        <font color="red">import</font> static pkg.MyClass.*;\
      <dt>instanceof\
      <dd>a <font color="red">instanceof</font> MyClass\
      <dt>int\
      <dd><font color="red">int</font>\
      <dt>int_literal\
      <dd>\
        <font color="red">11</font><br/>\
         <font color="red">0xB</font><br/>\
         <font color="red">013</font><br/>\
         <font color="red">0B1011</font>\
      <dt>interface\
      <dd>public <font color="red">interface</font> MyInterface { ... }\
      <dt>l_angle__meth_decl_type_params\
      <dd>public <font color="red">&lt;</font>T extends Number> void meth(T parm) {\
      <dt>l_angle__meth_invocation_type_args\
      <dd>MyClass.<font color="red">&lt;</font>Double>meth(x)\
      <dt>l_angle__type_args\
      <dd>MyClass<font color="red">&lt;</font>String>\
      <dt>l_angle__type_params\
      <dd>class MyClass<font color="red">&lt;</font>T extends Number> {\
      <dt>l_brack__array_decl\
      <dd>Object<font color="red">[</font>]\
      <dt>l_brack__index\
      <dd>a<font color="red">[</font>3]\
      <dt>l_curly__anno_array_init\
      <dd>@SuppressWarnings(<font color="red">{</font> "foo", "bar" })\
      <dt>l_curly__anon_class\
      <dd>new Object() <font color="red">{</font> ... }\
      <dt>l_curly__array_init\
      <dd>int[] ia = <font color="red">{</font> 1, 2 }<br/>new int[] <font color="red">{</font> 1, 2 }\
      <dt>l_curly__block\
      <dd><font color="red">{</font> int i = 0; i++; }\
      <dt>l_curly__catch\
      <dd>try { ... } catch (...) <font color="red">{</font> ...\
      <dt>l_curly__do\
      <dd>do <font color="red">{</font> ... } while (...);\
      <dt>l_curly__empty_anno_array_init\
      <dd>@SuppressWarnings(<font color="red">{</font>})\
      <dt>l_curly__empty_anon_class\
      <dd>new Object() <font color="red">{</font>}\
      <dt>l_curly__empty_array_init\
      <dd>int[] ia = <font color="red">{</font>};<br/>new int[] <font color="red">{</font>}\
      <dt>l_curly__empty_catch\
      <dd>try { ... } catch (...) <font color="red">{</font>}\
      <dt>l_curly__empty_meth_decl\
      <dd>void meth(...) <font color="red">{</font>}\
      <dt>l_curly__empty_type_decl\
      <dd>\
        class MyClass() <font color="red">{</font>}<br/>\
        interface MyInterface() <font color="red">{</font>}<br/>\
        interface @MyAnnotation <font color="red">{</font>}<br/>\
        enum MyEnum <font color="red">{</font>}\
      <dt>l_curly__enum_const\
      <dd>enum MyEnum { FOO <font color="red">{</font> ... } }\
      <dt>l_curly__finally\
      <dd>finally <font color="red">{</font> ... }\
      <dt>l_curly__for\
      <dd>for (...) <font color="red">{</font>\
      <dt>l_curly__if\
      <dd>if (...) <font color="red">{</font>\
      <dt>l_curly__instance_init\
      <dd>class MyClass { <font color="red">{</font> ... } }\
      <dt>l_curly__labeled_stat\
      <dd>LABEL: <font color="red">{</font>\
      <dt>l_curly__meth_decl\
      <dd>void meth(...) <font color="red">{</font> ... }\
      <dt>l_curly__static_init\
      <dd>class MyClass { static <font color="red">{</font> ... } }\
      <dt>l_curly__switch\
      <dd>switch (a) <font color="red">{</font>\
      <dt>l_curly__synchronized\
      <dd>synchronized (a) <font color="red">{</font>\
      <dt>l_curly__try\
      <dd>try <font color="red">{</font>\
      <dt>l_curly__type_decl\
      <dd>\
        class MyClass() <font color="red">{</font><br/>\
        interface MyInterface() <font color="red">{</font><br/>\
        interface @MyAnno <font color="red">{</font><br/>\
        enum MyEnum <font color="red">{</font>\
      <dt>l_curly__while\
      <dd>while (...) <font color="red">{</font>\
      <dt>l_paren__anno\
      <dd>@SuppressWarnings<font color="red">(</font>"foo")\
      <dt>l_paren__anno_elem_decl\
      <dd>interface @MyAnno { String engineer<font color="red">(</font>); }\
      <dt>l_paren__cast\
      <dd><font color="red">(</font>int) a\
      <dt>l_paren__catch\
      <dd>try { ... } catch <font color="red">(</font>Exception e) {\
      <dt>l_paren__do_while\
      <dd>do { ... } while <font color="red">(</font>...);\
      <dt>l_paren__for\
      <dd>for <font color="red">(</font>int i = 0; i  10; i++) {\
      <dt>l_paren__for_no_init\
      <dd>for <font color="red">(</font>; i  10; i++) {\
      <dt>l_paren__if\
      <dd>if <font color="red">(</font>...) {\
      <dt>l_paren__meth_invocation\
      <dd>a<font color="red">(</font>x, y)\
      <dt>l_paren__params\
      <dd>void meth<font color="red">(</font>int x, int y) {\
      <dt>l_paren__parenthesized\
      <dd><font color="red">(</font>a + b) * c\
      <dt>left_shift\
      <dd>a <font color="red">&lt;&lt;</font> 3\
      <dt>left_shift_assign\
      <dd>a <font color="red">&lt;&lt;=</font> 1\
      <dt>less\
      <dd>a <font color="red">&lt;</font> b\
      <dt>less_equal\
      <dd>a <font color="red">&lt;=</font> b\
      <dt>logical_complement\
      <dd><font color="red">!</font>a\
      <dt>long\
      <dd><font color="red">long</font>\
      <dt>long_literal\
      <dd>\
        <font color="red">11L</font><br/>\
        <font color="red">0xBL</font><br/>\
        <font color="red">013L</font><br/>\
        <font color="red">0B1011L</font>\
      <dt>minus__additive\
      <dd>a <font color="red">-</font> b\
      <dt>minus__unary\
      <dd><font color="red">-</font>a\
      <dt>minus_assign\
      <dd>a <font color="red">-=</font> b\
      <dt>modulo\
      <dd>a <font color="red">%</font> b\
      <dt>modulo_assign\
      <dd>a <font color="red">%=</font> b\
      <dt>multiply\
      <dd>a <font color="red">*</font> b\
      <dt>multiply_assign\
      <dd>a <font color="red">*=</font> b\
      <dt>name__ambiguous\
      <dd><font color="red">a</font>.<font color="red">b</font>.<font color="red">c</font>\
      <dt>name__anno\
      <dd>@<font color="red">MyAnnotation</font>("x")\
      <dt>name__anno_elem_decl\
      <dd>interface @MyAnno { String <font color="red">engineer</font>(); }\
      <dt>name__anno_member\
      <dd>@MyAnnotation(<font color="red">value</font> = "x")\
      <dt>name__ctor_decl\
      <dd><font color="red">MyClass</font>(...) {\
      <dt>name__import_component\
      <dd>import <font color="red">pkg</font>.<font color="red">pkg</font>.*;\
      <dt>name__import_type\
      <dd>import pkg.pkg.<font color="red">MyType</font>;\
      <dt>name__meth_decl\
      <dd>void <font color="red">main</font>(...) {\
      <dt>name__package_decl\
      <dd>package <font color="red">pkg</font>.<font color="red">pkg</font>.<font color="red">pkg</font>;\
      <dt>name__param\
      <dd>void meth(String <font color="red">param</font>)\
      <dt>name__qualified_type\
      <dd><font color="red">pkg</font>.<font color="red">MyType</font>\
      <dt>name__simple_type\
      <dd><font color="red">MyType</font> x;<br/>y = new <font color="red">MyType</font>();\
      <dt>name__type_decl\
      <dd>\
        class <font color="red">MyClass</font> { ... }<br/>\
        interface <font color="red">MyInterface</font> { ... }<br/>\
        interface @<font color="red">MyAnnotation</font> { ... }<br/>\
        enum <font color="red">MyEnum</font> { ... }\
      <dt>name__local_var_decl\
      <dd>int <font color="red">a</font>;\
      <dt>native\
      <dd><font color="red">native</font>\
      <dt>new\
      <dd><font color="red">new</font>\
      <dt>not_equal\
      <dd>a <font color="red">!=</font> b\
      <dt>null\
      <dd><font color="red">null</font>\
      <dt>or\
      <dd>a <font color="red">|</font> b\
      <dt>or_assign\
      <dd>a <font color="red">|=</font> b\
      <dt>package\
      <dd><font color="red">package</font> ...;\
      <dt>plus__additive\
      <dd>a <font color="red">+</font> b\
      <dt>plus__unary\
      <dd><font color="red">+</font>(a + b)\
      <dt>plus_assign\
      <dd>a <font color="red">+=</font> b\
      <dt>post_decr\
      <dd>x<font color="red">--</font>\
      <dt>post_incr\
      <dd>x<font color="red">++</font>\
      <dt>pre_decr\
      <dd><font color="red">--</font>x\
      <dt>pre_incr\
      <dd><font color="red">++</font>x\
      <dt>private\
      <dd><font color="red">private</font>\
      <dt>protected\
      <dd><font color="red">protected</font>\
      <dt>public\
      <dd><font color="red">public</font>\
      <dt>question__ternary\
      <dd>a <font color="red">?</font> b : c\
      <dt>question__wildcard_type\
      <dd>List&lt;<font color="red">?</font> extends InputStream>\
      <dt>r_angle__meth_decl_type_params\
      <dd>public &lt;T extends Number<font color="red">></font> void meth(T parm) {\
      <dt>r_angle__meth_invocation_type_args\
      <dd>MyClass.&lt;Double<font color="red">></font>meth(x)\
      <dt>r_angle__type_args\
      <dd>MyClass&lt;String<font color="red">></font>\
      <dt>r_angle__type_params\
      <dd>class MyClass&lt;T extends Number<font color="red">></font> {\
      <dt>r_brack__array_decl\
      <dd>Object[<font color="red">]</font>\
      <dt>r_brack__index\
      <dd>a[3<font color="red">]</font>\
      <dt>r_curly__anno_array_init\
      <dd>@SuppressWarnings({ "foo", "bar" <font color="red">}</font>)\
      <dt>r_curly__anon_class\
      <dd>new Object() { ... <font color="red">}</font>\
      <dt>r_curly__array_init\
      <dd>int[] ia = { 1, 2 <font color="red">};</font><br/>b = new int[] { 1, 2 <font color="red">}</font>;\
      <dt>r_curly__block\
      <dd>{ int i = 0; i++; <font color="red">}</font>\
      <dt>r_curly__catch\
      <dd>try { ... } catch (...) { ... <font color="red">}</font>\
      <dt>r_curly__do\
      <dd>do { ... <font color="red">}</font> while (...);\
      <dt>r_curly__else\
      <dd>else { ... <font color="red">}</font>\
      <dt>r_curly__empty_anno_array_init\
      <dd>@SuppressWarnings({<font color="red">}</font>)\
      <dt>r_curly__empty_anon_class\
      <dd>new Object() {<font color="red">}</font>\
      <dt>r_curly__empty_array_init\
      <dd>int[] ia = {<font color="red">}</font>;<br/>b = new int[] {<font color="red">}</font>;\
      <dt>r_curly__empty_catch\
      <dd>try { ... } catch (...) {<font color="red">}</font>\
      <dt>r_curly__empty_meth_decl\
      <dd>public MyClass(...) {<font color="red">}</font><br/>public method(...) {<font color="red">}</font>\
      <dt>r_curly__empty_type_decl\
      <dd>\
        class MyClass {<font color="red">}</font><br/>\
        interface MyInterface {<font color="red">}</font><br/>\
        @interface MyAnnotation {<font color="red">}</font><br/>\
        enum MyEnum {<font color="red">}</font>\
      <dt>r_curly__enum_const_decl\
      <dd>enum MyEnum { FOO { ... <font color="red">}</font> }\
      <dt>r_curly__finally\
      <dd>finally { ... <font color="red">}</font>\
      <dt>r_curly__for\
      <dd>for (...) { ... <font color="red">}</font>\
      <dt>r_curly__if\
      <dd>if (...) { ... <font color="red">}</font>\
      <dt>r_curly__instance_init\
      <dd>class MyClass { { ... <font color="red">}</font> }\
      <dt>r_curly__labeled_stat\
      <dd>LABEL: { ... <font color="red">}</font>\
      <dt>r_curly__meth_decl\
      <dd>\
        public MyClass(...) { ... <font color="red">}</font><br/>\
        public method(...) { ... <font color="red">}</font>\
      <dt>r_curly__static_init\
      <dd>class MyClass { static { ... <font color="red">}</font> }\
      <dt>r_curly__switch\
      <dd>switch (a) { ... <font color="red">}</font>\
      <dt>r_curly__synchronized\
      <dd>synchronized (a) { ... <font color="red">}</font>\
      <dt>r_curly__try\
      <dd>try { ... <font color="red">} catch {</font>\
      <dt>r_curly__type_decl\
      <dd>\
        class MyClass { ... <font color="red">}</font><br/>\
        interface MyInter { ... <font color="red">}</font><br/>\
        @interface MyAnno { ... <font color="red">}</font><br/>\
        enum MyEnum { ... <font color="red">}</font>\
      <dt>r_curly__while\
      <dd>while (...) { ... <font color="red">}</font>\
      <dt>r_paren__anno\
      <dd>@SuppressWarnings("foo"<font color="red">)</font>\
      <dt>r_paren__anno_elem_decl\
      <dd>interface @MyAnno { String engineer(<font color="red">)</font>; }\
      <dt>r_paren__cast\
      <dd>(int<font color="red">)</font> a\
      <dt>r_paren__catch\
      <dd>try { ... } catch (Exception e<font color="red">)</font> {\
      <dt>r_paren__do_while\
      <dd>do { ... } while (...<font color="red">)</font>;\
      <dt>r_paren__for\
      <dd>for (int i = 0; i &lt; 10; i++<font color="red">)</font> {\
      <dt>r_paren__for_no_update\
      <dd>for (int i = 0; i &lt; 10;<font color="red">)</font> {\
      <dt>r_paren__if\
      <dd>if (...<font color="red">)</font> {\
      <dt>r_paren__meth_invocation\
      <dd>a(x, y<font color="red">)</font>\
      <dt>r_paren__params\
      <dd>void meth(int a, int b<font color="red">)</font> {\
      <dt>r_paren__parenthesized\
      <dd>(a + b<font color="red">)</font> * c\
      <dt>return__expr\
      <dd><font color="red">return</font> x;\
      <dt>return__no_expr\
      <dd><font color="red">return</font>;\
      <dt>right_shift\
      <dd>a <font color="red">>></font> 3\
      <dt>right_shift_assign\
      <dd>a <font color="red">>>=</font> 2\
      <dt>semi__abstract_meth_decl\
      <dd>abstract meth(int x)<font color="red">;</font>\
      <dt>semi__anno_elem_decl\
      <dd>interface @MyAnno { String engineer()<font color="red">;</font> }\
      <dt>semi__empty_stat\
      <dd><font color="red">;</font>\
      <dt>semi__enum_decl\
      <dd>enum MyEnum { A, B, C<font color="red">;</font> public String toString() { ... } }\
      <dt>semi__field_decl\
      <dd>public int i<font color="red">;</font>\
      <dt>semi__for_condition_no_update\
      <dd>for (...; i < 3<font color="red">;</font>) {\
      <dt>semi__for_condition_update\
      <dd>for (...; i < 3<font color="red">;</font> i++) {\
      <dt>semi__for_init_condition\
      <dd>for (int i = 0<font color="red">;</font> i < 3;...\
      <dt>semi__for_init_no_condition\
      <dd>for (int i = 0<font color="red">;</font>;...\
      <dt>semi__for_no_condition_no_update\
      <dd>for (...;<font color="red">;</font>) {\
      <dt>semi__for_no_condition_update\
      <dd>for (...;<font color="red">;</font> i++) {\
      <dt>semi__for_no_init_condition\
      <dd>for (<font color="red">;</font> ...; ...) {\
      <dt>semi__for_no_init_no_condition\
      <dd>for (<font color="red">;</font>;...) {\
      <dt>semi__import\
      <dd>import pkg.*<font color="red">;</font><br/>import pkg.MyClass<font color="red">;</font>\
      <dt>semi__package_decl\
      <dd>package pkg.pkg<font color="red">;</font>\
      <dt>semi__statement\
      <dd>a = 7<font color="red">;</font>\
      <dt>semi__static_import\
      <dd>import static MyClass.*<font color="red">;</font>\
      <dt>semi__type_decl\
      <dd>class MyClass { <font color="red">;</font> }\
      <dt>short\
      <dd><font color="red">short</font>\
      <dt>star__type_import_on_demand\
      <dd>import pkg.pkg.<font color="red">*</font>;\
      <dt>static__static_import\
      <dd>import <font color="red">static</font> java.util.Map.Entry;\
      <dt>static__mod\
      <dd>\
        <font color="red">static</font> int x;<br/>\
        <font color="red">static</font> class MyClass {<br/>\
        <font color="red">static</font> void meth() {\
      <dt>static__static_init\
      <dd>class MyClass { <font color="red">static</font> { ... } }\
      <dt>string_literal\
      <dd><font color="red">"hello"</font>\
      <dt>super__ctor_call\
      <dd><font color="red">super</font>(x, y);\
      <dt>super__expr\
      <dd><font color="red">super</font>.meth();\
      <dt>super__type_bound\
      <dd>List&lt;T <font color="red">super</font> MyClass>\
      <dt>switch\
      <dd><font color="red">switch</font> (a) {\
      <dt>synchronized__mod\
      <dd><font color="red">synchronized</font> Object o;\
      <dt>synchronized__synchronized\
      <dd><font color="red">synchronized</font> (x) { ... }\
      <dt>this__ctor_call\
      <dd><font color="red">this</font>(a, b);\
      <dt>this__expr\
      <dd><font color="red">this</font>.meth()<br/><font color="red">this</font>.field\
      <dt>throw\
      <dd><font color="red">throw</font> new IOException();\
      <dt>throws\
      <dd><font color="red">throws</font>\
      <dt>transient\
      <dd><font color="red">transient</font>\
      <dt>true\
      <dd><font color="red">true</font>\
      <dt>try\
      <dd><font color="red">try</font> { ... } catch (...) { ... }\
      <dt>unsigned_right_shift\
      <dd>a <font color="red">>>></font> 3\
      <dt>unsigned_right_shift_assign\
      <dd>a <font color="red">>>>=</font> 2\
      <dt>void\
      <dd><font color="red">void</font> meth() {<br/><font color="red">void</font>.class\
      <dt>volatile\
      <dd><font color="red">volatile</font>\
      <dt>while__do\
      <dd>do { ... } <font color="red">while</font> (a > 0);\
      <dt>while__while\
      <dd><font color="red">while</font> (a > 0) { ... }\
      <dt>xor\
      <dd>a <font color="red">^</font> b\
      <dt>xor_assign\
      <dd>a <font color="red">^=</font> b\
    </dl>
de.unkrig.cscontrib.checks.Whitespace.whitespaceBefore.desc   = The Java elements which must be preceded with whitespace (or a line break)
de.unkrig.cscontrib.checks.Whitespace.noWhitespaceBefore.desc = The Java elements which must not be preceded with whitespace (or are preceded with a line break)
de.unkrig.cscontrib.checks.Whitespace.whitespaceAfter.desc    = The Java elements which must be followed by whitespace (or a line break)
de.unkrig.cscontrib.checks.Whitespace.noWhitespaceAfter.desc  = The Java elements which must not be followed by whitespace (or are followed by a line break)

# --------------- de.unkrig.WhitespaceAround ---------------

de.unkrig.cscontrib.checks.WhitespaceAround.name = de.unkrig.WhitespaceAround
de.unkrig.cscontrib.checks.WhitespaceAround.desc =\
	Verifies that a token is surrounded by whitespace.\
	<p>\
	<b>This check is superseded by 'de.unkrig.Whitespace'.</b>\
	<p>\
	The following tokens and token combinations are exempted from this check:\
	<dl>\
	  <dt><code>public MyClass() <font color="red">{}</font></code></dt>\
	  <dd>Empty constructor body (if '<code>allowEmptyConstructors</code>' is set)</dd>\
	  <dt><code>public void func() <font color="red">{}</font></code></dt>\
	  <dd>Empty method body (if '<code>allowEmptyMethods</code>' is set)</dd>\
	  <dt><code>catch (Exception e) <font color="red">{}</font></code></dt>\
	  <dd>Empty method body (if '<code>allowEmptyCatches</code>' is set)</dd>\
	  <dt><code>interface MyInterface <font color="red">{}</font></code></dt>\
	  <dd>Empty method body (if '<code>allowEmptyTypes</code>' is set)</dd>\
	  <dt><code><font color="red">})<br>};<br>},<br>}.</font></code></dt>\
	  <dd>Anonymous classes</dd>\
	  <dt><code>\
	    a = new <font color="red">{ x, y, z }</font><br/>\
	    Object[] oa = <font color="red">{ x, y, z }</font>\
	  </code></dt>\
	  <dd>Array initializer</dd>\
	  <dt><code>import pkg.name.<font color="red">*</font>;</code></dt>\
	  <dd>Import-on-demand declaration</dd>\
	  <dt><code>\
	    case 7<font color="red">:</font><br/>\
	    default<font color="red">:</font>\
	  </code></dt>\
	  <dd>Switch label</dd>\
	  <dt><code>for (String var <font color="red">:</font> list { ...</code></dt>\
	  <dd>Enhanced FOR statement (if '<code>ignoreEnhancedForColon</code>' is set)</dd>\
	</dl>
de.unkrig.cscontrib.checks.WhitespaceAround.allowEmptyConstructors = Allow empty constructor bodies
de.unkrig.cscontrib.checks.WhitespaceAround.allowEmptyMethods      = Allow empty method bodies
de.unkrig.cscontrib.checks.WhitespaceAround.allowEmptyCatches      = Allow empty catch blocks
de.unkrig.cscontrib.checks.WhitespaceAround.allowEmptyTypes        = Allow empty class and interface bodies
de.unkrig.cscontrib.checks.WhitespaceAround.ignoreEnhancedForColon = Whether or not to ignore a colon in an enhanced for loop
de.unkrig.cscontrib.checks.WhitespaceAround.tokens                 = Tokens to check

# --------------- de.unkrig.WrapAndIndent ---------------

de.unkrig.cscontrib.checks.WrapAndIndent.name = de.unkrig.WrapAndIndent
de.unkrig.cscontrib.checks.WrapAndIndent.desc =\
	Statements must be uniformly wrapped and indented.\
	<p>\
	This check supersedes the following checks:\
	<ul>\
	  <li>Left curly brace placement\
	  <li>Right curly brace placement\
	  <li>Operator wrap\
	</ul>

de.unkrig.cscontrib.checks.WrapAndIndent.basicOffset                      = How many spaces to use for new indentation level
de.unkrig.cscontrib.checks.WrapAndIndent.allowOneLineClassDecl            = A complete class declaration in one single line
de.unkrig.cscontrib.checks.WrapAndIndent.allowOneLineInterfaceDecl        = A complete interface declaration in one single line
de.unkrig.cscontrib.checks.WrapAndIndent.allowOneLineEnumDecl             = A complete enum declaration in one single line
de.unkrig.cscontrib.checks.WrapAndIndent.allowOneLineAnnoDecl             = A complete annotation declaration in one single line
de.unkrig.cscontrib.checks.WrapAndIndent.allowOneLineCtorDecl             = A complete constructor declaration in one single line
de.unkrig.cscontrib.checks.WrapAndIndent.allowOneLineMethDecl             = A complete method declaration in one single line
de.unkrig.cscontrib.checks.WrapAndIndent.allowOneLineSwitchBlockStmtGroup = A complete switch block statement group in one single line, e.g. 'case 7: meth(); break;'

de.unkrig.cscontrib.checks.WrapAndIndent.wrapClassDeclBeforeClass         = Wrap class declaration before 'class' keyword
de.unkrig.cscontrib.checks.WrapAndIndent.wrapInterfaceDeclBeforeInterface = Wrap interface declaration before 'interface' keyword
de.unkrig.cscontrib.checks.WrapAndIndent.wrapEnumDeclBeforeEnum           = Wrap enum declaration before 'enum' keyword
de.unkrig.cscontrib.checks.WrapAndIndent.wrapAnnoDeclBeforeAt             = Wrap annotation declaration before '@'
de.unkrig.cscontrib.checks.WrapAndIndent.wrapFieldDeclBeforeName          = Wrap field declaration before the field name
de.unkrig.cscontrib.checks.WrapAndIndent.wrapCtorDeclBeforeName           = Wrap constructor declaration between the modifiers and the class name
de.unkrig.cscontrib.checks.WrapAndIndent.wrapMethDeclBeforeName           = Wrap method declaration between the return type and the method name
de.unkrig.cscontrib.checks.WrapAndIndent.wrapLocVarDeclBeforeName         = Wrap local variable declaration between the type and the variable name

de.unkrig.cscontrib.checks.WrapAndIndent.wrapTypeDeclBeforeLCurly      = Wrap type declaration before the opening curly brace
de.unkrig.cscontrib.checks.WrapAndIndent.wrapCtorDeclBeforeLCurly      = Wrap constructor declaration before the opening curly brace
de.unkrig.cscontrib.checks.WrapAndIndent.wrapMethodDeclBeforeLCurly    = Wrap method declaration before the opening curly brace
de.unkrig.cscontrib.checks.WrapAndIndent.wrapDoBeforeLCurly            = Wrap DO statement before the opening curly brace
de.unkrig.cscontrib.checks.WrapAndIndent.wrapArrayInitBeforeLCurly     = Wrap array initializer before the opening curly brace
de.unkrig.cscontrib.checks.WrapAndIndent.wrapAnonClassDeclBeforeLCurly = Wrap anonymous class declaration before the opening curly brace

de.unkrig.cscontrib.checks.WrapAndIndent.wrapBeforeBinaryOperator = Wrap expression before "+ - * / % && | ^ << >> >>>", their "compound assignment" counterparts and/or "= . <= < == != >= > &&&& || instanceof"
de.unkrig.cscontrib.checks.WrapAndIndent.wrapAfterBinaryOperator  = Wrap expression after "+ - * / % && | ^ << >> >>>", their "compound assignment" counterparts and/or "= . <= < == != >= > &&&& || instanceof"

# --------------- de.unkrig.ZeroParameterSuperconstructorInvocation ---------------

de.unkrig.cscontrib.checks.ZeroParameterSuperconstructorInvocation.name = de.unkrig.ZeroParameterSuperconstructorInvocation
de.unkrig.cscontrib.checks.ZeroParameterSuperconstructorInvocation.desc = Verifies that no constructor calls the zero-parameter superconstructor.

# Custom filters, in alphabetical order.

# --------------- de.unkrig.SuppressionLine ---------------

de.unkrig.cscontrib.filters.SuppressionLine.name = de.unkrig.SuppressionLine
de.unkrig.cscontrib.filters.SuppressionLine.desc =\
	Events (i.e. CheckStyle warnings) are switched off by a 'magic line' ('offCommentFormat') or back on by another \
	'magic line' ('onCommentFormat').\n\
	After the 'off' magic line, events do not show if at least one of the following conditions is true:\n\
	<ul>\n\
	  <li>The 'checkNameFormat' (if set) is found in the check name (e.g. 'de.unkrig.cscontrib.checks.Alignment')\n\
	  <li>The 'messageFormat' (if set) is found in the event message\n\
	  <li>The 'moduleIdFormat' (if set) is found in the ID of the module that generated the event\n\
	</ul>\n\
	\n\
	This filter can only work if a 'FileContentsHolder' module exists in the configuration.
de.unkrig.cscontrib.filters.SuppressionLine.offFormat       = Line pattern to trigger filter to begin suppression
de.unkrig.cscontrib.filters.SuppressionLine.onFormat        = Line pattern to trigger filter to end suppression
de.unkrig.cscontrib.filters.SuppressionLine.checkNameFormat = Check name pattern to suppress
de.unkrig.cscontrib.filters.SuppressionLine.messageFormat   = Message pattern to suppress
de.unkrig.cscontrib.filters.SuppressionLine.moduleIdFormat  = Module ID pattern to suppress
